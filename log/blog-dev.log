2020-02-20 15:42:18.026  INFO 3376 --- [restartedMain] com.peng.blog.BlogApplication            : Starting BlogApplication on LAPTOP-3JGI280N with PID 3376 (D:\workspaces\ideaWebWorkSpace\blog\target\classes started by 23185 in D:\workspaces\ideaWebWorkSpace\blog)
2020-02-20 15:42:18.033 DEBUG 3376 --- [restartedMain] com.peng.blog.BlogApplication            : Running with Spring Boot v1.5.9.RELEASE, Spring v4.3.13.RELEASE
2020-02-20 15:42:18.034  INFO 3376 --- [restartedMain] com.peng.blog.BlogApplication            : The following profiles are active: dev
2020-02-20 15:42:18.460  INFO 3376 --- [restartedMain] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@562888d7: startup date [Thu Feb 20 15:42:18 CST 2020]; root of context hierarchy
2020-02-20 15:42:21.477  INFO 3376 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)
2020-02-20 15:42:21.493  INFO 3376 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-02-20 15:42:21.494  INFO 3376 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.23
2020-02-20 15:42:21.651  INFO 3376 --- [localhost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-02-20 15:42:21.651  INFO 3376 --- [localhost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 3191 ms
2020-02-20 15:42:21.918  INFO 3376 --- [localhost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/]
2020-02-20 15:42:21.922  INFO 3376 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*]
2020-02-20 15:42:21.923  INFO 3376 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
2020-02-20 15:42:21.923  INFO 3376 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*]
2020-02-20 15:42:21.923  INFO 3376 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*]
2020-02-20 15:42:23.784  INFO 3376 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit 'default'
2020-02-20 15:42:23.808  INFO 3376 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [
	name: default
	...]
2020-02-20 15:42:23.956  INFO 3376 --- [restartedMain] org.hibernate.Version                    : HHH000412: Hibernate Core {5.0.12.Final}
2020-02-20 15:42:23.958  INFO 3376 --- [restartedMain] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found
2020-02-20 15:42:23.959  INFO 3376 --- [restartedMain] org.hibernate.cfg.Environment            : HHH000021: Bytecode provider name : javassist
2020-02-20 15:42:24.057  INFO 3376 --- [restartedMain] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.0.1.Final}
2020-02-20 15:42:24.403  INFO 3376 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL5Dialect
2020-02-20 15:42:24.999  INFO 3376 --- [restartedMain] org.hibernate.tool.hbm2ddl.SchemaUpdate  : HHH000228: Running hbm2ddl schema update
2020-02-20 15:42:25.702  INFO 3376 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-02-20 15:42:26.208  INFO 3376 --- [restartedMain] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
2020-02-20 15:42:27.207  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@562888d7: startup date [Thu Feb 20 15:42:18 CST 2020]; root of context hierarchy
2020-02-20 15:42:27.308  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[ || /index.html],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.index(org.springframework.data.domain.Pageable,org.springframework.ui.Model)
2020-02-20 15:42:27.310  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/blog/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.check(int,org.springframework.ui.Model) throws com.peng.blog.exception.NotFoundException
2020-02-20 15:42:27.311  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.client.BlogController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 15:42:27.311  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comments/{id}],methods=[GET]}" onto public java.util.List<com.peng.blog.entity.Comment> com.peng.blog.web.client.BlogController.comments(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 15:42:27.311  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/content/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.content(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 15:42:27.311  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/reply/{parent}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.reply(int,com.peng.blog.entity.Comment)
2020-02-20 15:42:27.311  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comment/{blog}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.commentBlog(int,com.peng.blog.entity.Comment)
2020-02-20 15:42:27.312  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/archive],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.archive(org.springframework.ui.Model)
2020-02-20 15:42:27.312  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/tags],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TagClientController.showBlogByTag(com.peng.blog.utils.MyPage,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 15:42:27.313  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/types],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TypeClientController.showBlogsByType(org.springframework.data.domain.Pageable,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 15:42:27.316  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.add(com.peng.blog.entity.Blog,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 15:42:27.316  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog || /manage/blog/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.list(org.springframework.data.domain.Pageable,org.springframework.ui.Model,javax.servlet.http.HttpSession)
2020-02-20 15:42:27.317  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/search]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.search(org.springframework.data.domain.Pageable,com.peng.blog.entity.Blog,org.springframework.ui.Model)
2020-02-20 15:42:27.317  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/publish],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.publish(org.springframework.ui.Model,com.peng.blog.entity.Blog)
2020-02-20 15:42:27.318  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/del],methods=[GET]}" onto public com.peng.blog.utils.Message com.peng.blog.web.management.BlogManageController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 15:42:27.318  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 15:42:27.326  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/login],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.LoginController.login(java.lang.String,java.lang.String,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 15:42:27.326  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/logout],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.LoginController.logout(javax.servlet.http.HttpSession)
2020-02-20 15:42:27.329  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.add(com.peng.blog.entity.Tag,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 15:42:27.330  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag || /manage/tag/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.list(int,org.springframework.ui.Model)
2020-02-20 15:42:27.330  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 15:42:27.330  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 15:42:27.331  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 15:42:27.335  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.add(com.peng.blog.entity.Type,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 15:42:27.336  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/list || /manage/type],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.list(int,org.springframework.ui.Model)
2020-02-20 15:42:27.337  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 15:42:27.338  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 15:42:27.339  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 15:42:27.342  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t2]}" onto public java.lang.String com.peng.blog.web.TestController.t2(java.lang.String,int,boolean) throws com.peng.blog.exception.NotFoundException
2020-02-20 15:42:27.342  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t1]}" onto public java.lang.String com.peng.blog.web.TestController.t1(java.lang.String) throws com.peng.blog.exception.NotFoundException
2020-02-20 15:42:27.347  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t3]}" onto public java.lang.String com.peng.blog.web.TestController.t3(int)
2020-02-20 15:42:27.351  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2020-02-20 15:42:27.352  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error],produces=[text/html]}" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2020-02-20 15:42:27.389  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/about] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 15:42:27.389  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 15:42:27.389  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/index.html] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 15:42:27.389  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/welcome] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 15:42:27.389  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/type/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 15:42:27.390  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/tag/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 15:42:27.423  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 15:42:27.424  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 15:42:27.452  INFO 3376 --- [restartedMain] .m.m.a.ExceptionHandlerExceptionResolver : Detected @ExceptionHandler methods in globalExceptionHandler
2020-02-20 15:42:27.499  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 15:42:28.178  INFO 3376 --- [restartedMain] oConfiguration$WelcomePageHandlerMapping : Adding welcome page: class path resource [static/index.html]
2020-02-20 15:42:28.633  INFO 3376 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-02-20 15:42:28.678  INFO 3376 --- [restartedMain] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2020-02-20 15:42:28.945  INFO 3376 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2020-02-20 15:42:28.971  INFO 3376 --- [restartedMain] com.peng.blog.BlogApplication            : Started BlogApplication in 12.097 seconds (JVM running for 15.385)
2020-02-20 15:43:38.353  INFO 3376 --- [http-nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2020-02-20 15:43:38.354  INFO 3376 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2020-02-20 15:43:38.424  INFO 3376 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 70 ms
2020-02-20 15:43:39.348  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 15:43:41.662  WARN 3376 --- [http-nio-8080-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 15:43:41.967  WARN 3376 --- [http-nio-8080-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 15:43:42.123  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 15:44:27.732  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 15:44:27.816  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:44:37.030  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, 17]}
2020-02-20 15:44:37.080  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:44:37.695  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, 1]}
2020-02-20 15:44:37.740  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:44:41.144  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, 55]}
2020-02-20 15:44:41.198  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:44:43.128  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, 1]}
2020-02-20 15:44:43.169  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:45:12.882  INFO 3376 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, 43]}
2020-02-20 15:45:12.926  INFO 3376 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:45:15.839  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, null]}
2020-02-20 15:45:16.014  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:45:22.273  INFO 3376 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 15:45:22.307  INFO 3376 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:45:24.841  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, null]}
2020-02-20 15:45:24.889  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:45:32.318  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 15:45:32.347  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:45:35.238  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, null]}
2020-02-20 15:45:35.271  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:45:36.426  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, 1]}
2020-02-20 15:45:36.465  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:45:42.068  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, 9]}
2020-02-20 15:45:42.102  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:45:44.482  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, 6]}
2020-02-20 15:45:44.516  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:45:50.274  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/archive', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.archive', args=[{}]}
2020-02-20 15:45:50.289  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:archive
2020-02-20 15:46:11.573  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 15:46:11.605  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:46:13.084  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, 17]}
2020-02-20 15:46:13.119  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:46:51.530  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 15:46:51.562  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:46:53.332  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, 17]}
2020-02-20 15:46:53.383  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:46:55.483  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, 2]}
2020-02-20 15:46:55.532  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:46:58.946  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, 6]}
2020-02-20 15:46:58.981  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:47:00.634  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, 9]}
2020-02-20 15:47:00.663  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:47:02.329  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, 12]}
2020-02-20 15:47:02.369  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:47:03.962  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/archive', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.archive', args=[{}]}
2020-02-20 15:47:03.978  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:archive
2020-02-20 15:49:49.839  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 15:49:49.900  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 15:49:58.761  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], ceshi , {}]}
2020-02-20 15:49:58.781  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 15:50:11.277  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], ceshi , {}]}
2020-02-20 15:50:11.283  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 15:50:57.108  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 15:50:57.176  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 15:51:00.011  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], ceshi , {}]}
2020-02-20 15:51:00.024  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 15:51:09.458  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 15:51:09.486  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:51:13.330  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, null]}
2020-02-20 15:51:13.378  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:51:15.043  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 15:51:15.091  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 15:51:19.430  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], ceshi , {}]}
2020-02-20 15:51:19.460  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 15:52:04.056  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 15:52:04.126  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 15:52:08.413  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], jpa, {}]}
2020-02-20 15:52:08.426  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 15:52:16.444  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], jpa, {}]}
2020-02-20 15:52:16.454  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 15:52:21.040  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], jpa, {}]}
2020-02-20 15:52:21.051  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 15:52:22.221  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 15:52:22.379  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 15:52:26.431  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], jpa, {}]}
2020-02-20 15:52:26.462  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 15:55:12.829  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 15:55:13.007  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 15:55:22.290  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], jpa, {}]}
2020-02-20 15:55:22.298  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 15:55:36.765  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 15:55:36.806  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:55:51.289  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 15:55:51.348  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 15:55:56.974  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], jpa, {}]}
2020-02-20 15:55:56.986  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 15:56:01.014  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, null]}
2020-02-20 15:56:01.069  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:56:04.200  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 15:56:04.262  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 15:56:11.436  INFO 3376 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试2, {}]}
2020-02-20 15:56:11.442  INFO 3376 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 15:56:26.194  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 15:56:26.253  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 15:56:28.576  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 15:56:28.628  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 15:56:37.704  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 15:56:37.728  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:56:49.175  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, null]}
2020-02-20 15:56:49.208  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:56:49.879  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/archive', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.archive', args=[{}]}
2020-02-20 15:56:49.896  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:archive
2020-02-20 15:56:51.906  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/archive', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.archive', args=[{}]}
2020-02-20 15:56:51.919  INFO 3376 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:archive
2020-02-20 15:56:52.674  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 15:56:52.696  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 15:56:53.813  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, null]}
2020-02-20 15:56:53.850  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 15:57:08.201  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/archive', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.archive', args=[{}]}
2020-02-20 15:57:08.215  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:archive
2020-02-20 15:57:08.981  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 15:57:09.029  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 15:57:11.804  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试2, {}]}
2020-02-20 15:57:11.813  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 15:57:20.847  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试2, {}]}
2020-02-20 15:57:20.855  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:01:20.252  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:01:20.313  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:01:23.399  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试2, {}]}
2020-02-20 16:01:23.404  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:01:26.485  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:01:26.545  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:01:28.224  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试2, {}]}
2020-02-20 16:01:28.230  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:01:31.133  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试2, {}]}
2020-02-20 16:01:31.138  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:02:46.406  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:02:46.469  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:08:04.238  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:08:04.289  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:08:05.235  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:08:05.304  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:08:07.731  INFO 3376 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:08:07.743  INFO 3376 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:08:09.146  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试2, {}]}
2020-02-20 16:08:09.150  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:08:11.104  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试9, {}]}
2020-02-20 16:08:11.111  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:08:13.038  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试8, {}]}
2020-02-20 16:08:13.046  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:08:14.977  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试7, {}]}
2020-02-20 16:08:14.984  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:08:21.456  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试9, {}]}
2020-02-20 16:08:21.466  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:09:26.086  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:09:26.167  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:09:29.114  INFO 3376 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 首页, {}]}
2020-02-20 16:09:29.119  INFO 3376 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:09:31.382  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:09:31.397  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:09:33.157  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试2, {}]}
2020-02-20 16:09:33.162  INFO 3376 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:10:39.221  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:10:39.285  INFO 3376 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:10:40.901  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 16:10:40.925  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 16:10:43.331  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:10:43.382  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:10:45.061  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 16:10:45.091  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 16:10:49.558  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:10:49.599  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:11:29.475  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:11:29.538  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:11:32.444  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 16:11:32.472  INFO 3376 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 16:11:35.117  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:11:35.171  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:11:36.372  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 16:11:36.395  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 16:11:39.207  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, null]}
2020-02-20 16:11:39.233  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 16:11:40.325  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/archive', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.archive', args=[{}]}
2020-02-20 16:11:40.341  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:archive
2020-02-20 16:11:40.970  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, null]}
2020-02-20 16:11:41.000  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 16:11:41.705  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 16:11:41.727  INFO 3376 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 16:11:42.567  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/archive', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.archive', args=[{}]}
2020-02-20 16:11:42.580  INFO 3376 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:archive
2020-02-20 16:11:50.379  INFO 3376 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:11:50.422  INFO 3376 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:11:57.091  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/archive', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.archive', args=[{}]}
2020-02-20 16:11:57.101  INFO 3376 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:archive
2020-02-20 16:12:00.782  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 16:12:00.814  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 16:12:01.556  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, null]}
2020-02-20 16:12:01.583  INFO 3376 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 16:12:02.477  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:12:02.521  INFO 3376 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:35:45.340  INFO 3376 --- [Thread-30] ationConfigEmbeddedWebApplicationContext : Closing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@562888d7: startup date [Thu Feb 20 15:42:18 CST 2020]; root of context hierarchy
2020-02-20 16:35:45.364  INFO 3376 --- [Thread-30] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown
2020-02-20 16:35:45.367  INFO 3376 --- [Thread-30] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'
2020-02-20 16:35:46.628  INFO 3376 --- [restartedMain] com.peng.blog.BlogApplication            : Starting BlogApplication on LAPTOP-3JGI280N with PID 3376 (D:\workspaces\ideaWebWorkSpace\blog\target\classes started by 23185 in D:\workspaces\ideaWebWorkSpace\blog)
2020-02-20 16:35:46.629 DEBUG 3376 --- [restartedMain] com.peng.blog.BlogApplication            : Running with Spring Boot v1.5.9.RELEASE, Spring v4.3.13.RELEASE
2020-02-20 16:35:46.629  INFO 3376 --- [restartedMain] com.peng.blog.BlogApplication            : The following profiles are active: dev
2020-02-20 16:35:46.650  INFO 3376 --- [restartedMain] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@3da7af25: startup date [Thu Feb 20 16:35:46 CST 2020]; root of context hierarchy
2020-02-20 16:35:48.036  INFO 3376 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)
2020-02-20 16:35:48.037  INFO 3376 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-02-20 16:35:48.040  INFO 3376 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.23
2020-02-20 16:35:48.083  INFO 3376 --- [localhost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-02-20 16:35:48.084  INFO 3376 --- [localhost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1434 ms
2020-02-20 16:35:48.154  INFO 3376 --- [localhost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/]
2020-02-20 16:35:48.154  INFO 3376 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*]
2020-02-20 16:35:48.155  INFO 3376 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
2020-02-20 16:35:48.155  INFO 3376 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*]
2020-02-20 16:35:48.155  INFO 3376 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*]
2020-02-20 16:35:49.327  INFO 3376 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit 'default'
2020-02-20 16:35:49.327  INFO 3376 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [
	name: default
	...]
2020-02-20 16:35:49.393  INFO 3376 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL5Dialect
2020-02-20 16:35:49.460  INFO 3376 --- [restartedMain] org.hibernate.tool.hbm2ddl.SchemaUpdate  : HHH000228: Running hbm2ddl schema update
2020-02-20 16:35:50.607  INFO 3376 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-02-20 16:35:50.716  INFO 3376 --- [restartedMain] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
2020-02-20 16:35:51.162  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@3da7af25: startup date [Thu Feb 20 16:35:46 CST 2020]; root of context hierarchy
2020-02-20 16:35:51.178  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[ || /index.html],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.index(org.springframework.data.domain.Pageable,org.springframework.ui.Model)
2020-02-20 16:35:51.178  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/blog/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.check(int,org.springframework.ui.Model) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:35:51.178  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.client.BlogController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 16:35:51.179  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comments/{id}],methods=[GET]}" onto public java.util.List<com.peng.blog.entity.Comment> com.peng.blog.web.client.BlogController.comments(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:35:51.179  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/content/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.content(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:35:51.179  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/reply/{parent}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.reply(int,com.peng.blog.entity.Comment)
2020-02-20 16:35:51.179  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comment/{blog}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.commentBlog(int,com.peng.blog.entity.Comment)
2020-02-20 16:35:51.180  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/archive],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.archive(org.springframework.ui.Model)
2020-02-20 16:35:51.180  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/searchPage],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.searchPage(java.lang.String,org.springframework.ui.Model)
2020-02-20 16:35:51.180  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/tags],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TagClientController.showBlogByTag(com.peng.blog.utils.MyPage,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 16:35:51.181  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/types],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TypeClientController.showBlogsByType(org.springframework.data.domain.Pageable,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 16:35:51.182  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.add(com.peng.blog.entity.Blog,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:35:51.183  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog || /manage/blog/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.list(org.springframework.data.domain.Pageable,org.springframework.ui.Model,javax.servlet.http.HttpSession)
2020-02-20 16:35:51.183  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/search]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.search(org.springframework.data.domain.Pageable,com.peng.blog.entity.Blog,org.springframework.ui.Model)
2020-02-20 16:35:51.183  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/publish],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.publish(org.springframework.ui.Model,com.peng.blog.entity.Blog)
2020-02-20 16:35:51.183  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/del],methods=[GET]}" onto public com.peng.blog.utils.Message com.peng.blog.web.management.BlogManageController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:35:51.184  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:35:51.184  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/login],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.LoginController.login(java.lang.String,java.lang.String,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:35:51.185  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/logout],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.LoginController.logout(javax.servlet.http.HttpSession)
2020-02-20 16:35:51.188  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.add(com.peng.blog.entity.Tag,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:35:51.188  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag || /manage/tag/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.list(int,org.springframework.ui.Model)
2020-02-20 16:35:51.188  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 16:35:51.188  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:35:51.189  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:35:51.190  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.add(com.peng.blog.entity.Type,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:35:51.191  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/list || /manage/type],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.list(int,org.springframework.ui.Model)
2020-02-20 16:35:51.191  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 16:35:51.191  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:35:51.191  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:35:51.192  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t2]}" onto public java.lang.String com.peng.blog.web.TestController.t2(java.lang.String,int,boolean) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:35:51.192  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t1]}" onto public java.lang.String com.peng.blog.web.TestController.t1(java.lang.String) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:35:51.193  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t3]}" onto public java.lang.String com.peng.blog.web.TestController.t3(int)
2020-02-20 16:35:51.194  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2020-02-20 16:35:51.195  INFO 3376 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error],produces=[text/html]}" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2020-02-20 16:35:51.211  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/about] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:35:51.211  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:35:51.211  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/index.html] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:35:51.211  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/welcome] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:35:51.211  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/type/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:35:51.211  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/tag/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:35:51.218  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 16:35:51.218  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 16:35:51.228  INFO 3376 --- [restartedMain] .m.m.a.ExceptionHandlerExceptionResolver : Detected @ExceptionHandler methods in globalExceptionHandler
2020-02-20 16:35:51.238  INFO 3376 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 16:35:51.285  INFO 3376 --- [restartedMain] oConfiguration$WelcomePageHandlerMapping : Adding welcome page: class path resource [static/index.html]
2020-02-20 16:35:51.529  INFO 3376 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-02-20 16:35:51.572  INFO 3376 --- [restartedMain] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2020-02-20 16:35:51.594  INFO 3376 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2020-02-20 16:35:51.596  INFO 3376 --- [restartedMain] com.peng.blog.BlogApplication            : Started BlogApplication in 5.167 seconds (JVM running for 3218.01)
2020-02-20 16:42:49.880  INFO 18700 --- [restartedMain] com.peng.blog.BlogApplication            : Starting BlogApplication on LAPTOP-3JGI280N with PID 18700 (D:\workspaces\ideaWebWorkSpace\blog\target\classes started by 23185 in D:\workspaces\ideaWebWorkSpace\blog)
2020-02-20 16:42:49.881 DEBUG 18700 --- [restartedMain] com.peng.blog.BlogApplication            : Running with Spring Boot v1.5.9.RELEASE, Spring v4.3.13.RELEASE
2020-02-20 16:42:49.881  INFO 18700 --- [restartedMain] com.peng.blog.BlogApplication            : The following profiles are active: dev
2020-02-20 16:42:50.277  INFO 18700 --- [restartedMain] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@ea93fd: startup date [Thu Feb 20 16:42:50 CST 2020]; root of context hierarchy
2020-02-20 16:42:55.460  INFO 18700 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)
2020-02-20 16:42:55.479  INFO 18700 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-02-20 16:42:55.480  INFO 18700 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.23
2020-02-20 16:42:55.686  INFO 18700 --- [localhost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-02-20 16:42:55.687  INFO 18700 --- [localhost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 5410 ms
2020-02-20 16:42:56.163  INFO 18700 --- [localhost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/]
2020-02-20 16:42:56.170  INFO 18700 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*]
2020-02-20 16:42:56.171  INFO 18700 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
2020-02-20 16:42:56.171  INFO 18700 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*]
2020-02-20 16:42:56.171  INFO 18700 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*]
2020-02-20 16:42:57.852  INFO 18700 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit 'default'
2020-02-20 16:42:57.882  INFO 18700 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [
	name: default
	...]
2020-02-20 16:42:58.020  INFO 18700 --- [restartedMain] org.hibernate.Version                    : HHH000412: Hibernate Core {5.0.12.Final}
2020-02-20 16:42:58.021  INFO 18700 --- [restartedMain] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found
2020-02-20 16:42:58.023  INFO 18700 --- [restartedMain] org.hibernate.cfg.Environment            : HHH000021: Bytecode provider name : javassist
2020-02-20 16:42:58.105  INFO 18700 --- [restartedMain] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.0.1.Final}
2020-02-20 16:42:58.363  INFO 18700 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL5Dialect
2020-02-20 16:42:58.984  INFO 18700 --- [restartedMain] org.hibernate.tool.hbm2ddl.SchemaUpdate  : HHH000228: Running hbm2ddl schema update
2020-02-20 16:43:00.028  INFO 18700 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-02-20 16:43:00.413  INFO 18700 --- [restartedMain] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
2020-02-20 16:43:01.376  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@ea93fd: startup date [Thu Feb 20 16:42:50 CST 2020]; root of context hierarchy
2020-02-20 16:43:01.465  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[ || /index.html],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.index(org.springframework.data.domain.Pageable,org.springframework.ui.Model)
2020-02-20 16:43:01.466  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/blog/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.check(int,org.springframework.ui.Model) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:43:01.467  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.client.BlogController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 16:43:01.467  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comments/{id}],methods=[GET]}" onto public java.util.List<com.peng.blog.entity.Comment> com.peng.blog.web.client.BlogController.comments(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:43:01.468  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/content/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.content(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:43:01.469  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/reply/{parent}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.reply(int,com.peng.blog.entity.Comment)
2020-02-20 16:43:01.469  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/archive],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.archive(org.springframework.ui.Model)
2020-02-20 16:43:01.470  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/searchPage],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.searchPage(java.lang.String,org.springframework.ui.Model)
2020-02-20 16:43:01.470  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comment/{blog}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.commentBlog(int,com.peng.blog.entity.Comment)
2020-02-20 16:43:01.472  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/tags],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TagClientController.showBlogByTag(com.peng.blog.utils.MyPage,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 16:43:01.473  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/types],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TypeClientController.showBlogsByType(org.springframework.data.domain.Pageable,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 16:43:01.477  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.add(com.peng.blog.entity.Blog,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:43:01.477  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog || /manage/blog/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.list(org.springframework.data.domain.Pageable,org.springframework.ui.Model,javax.servlet.http.HttpSession)
2020-02-20 16:43:01.478  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/search]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.search(org.springframework.data.domain.Pageable,com.peng.blog.entity.Blog,org.springframework.ui.Model)
2020-02-20 16:43:01.479  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/publish],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.publish(org.springframework.ui.Model,com.peng.blog.entity.Blog)
2020-02-20 16:43:01.479  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:43:01.480  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/del],methods=[GET]}" onto public com.peng.blog.utils.Message com.peng.blog.web.management.BlogManageController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:43:01.481  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/login],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.LoginController.login(java.lang.String,java.lang.String,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:43:01.481  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/logout],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.LoginController.logout(javax.servlet.http.HttpSession)
2020-02-20 16:43:01.486  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.add(com.peng.blog.entity.Tag,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:43:01.486  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag || /manage/tag/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.list(int,org.springframework.ui.Model)
2020-02-20 16:43:01.486  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 16:43:01.487  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:43:01.487  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:43:01.489  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.add(com.peng.blog.entity.Type,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:43:01.489  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/list || /manage/type],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.list(int,org.springframework.ui.Model)
2020-02-20 16:43:01.490  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 16:43:01.490  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:43:01.490  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:43:01.491  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t2]}" onto public java.lang.String com.peng.blog.web.TestController.t2(java.lang.String,int,boolean) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:43:01.492  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t1]}" onto public java.lang.String com.peng.blog.web.TestController.t1(java.lang.String) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:43:01.492  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t3]}" onto public java.lang.String com.peng.blog.web.TestController.t3(int)
2020-02-20 16:43:01.495  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2020-02-20 16:43:01.495  INFO 18700 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error],produces=[text/html]}" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2020-02-20 16:43:01.522  INFO 18700 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/about] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:43:01.522  INFO 18700 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:43:01.522  INFO 18700 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/index.html] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:43:01.522  INFO 18700 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/welcome] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:43:01.523  INFO 18700 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/type/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:43:01.523  INFO 18700 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/tag/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:43:01.538  INFO 18700 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 16:43:01.538  INFO 18700 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 16:43:01.563  INFO 18700 --- [restartedMain] .m.m.a.ExceptionHandlerExceptionResolver : Detected @ExceptionHandler methods in globalExceptionHandler
2020-02-20 16:43:01.593  INFO 18700 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 16:43:02.025  INFO 18700 --- [restartedMain] oConfiguration$WelcomePageHandlerMapping : Adding welcome page: class path resource [static/index.html]
2020-02-20 16:43:02.400  INFO 18700 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-02-20 16:43:02.462  INFO 18700 --- [restartedMain] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2020-02-20 16:43:02.563  INFO 18700 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2020-02-20 16:43:02.567  INFO 18700 --- [restartedMain] com.peng.blog.BlogApplication            : Started BlogApplication in 13.468 seconds (JVM running for 15.62)
2020-02-20 16:45:29.820  INFO 18700 --- [http-nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2020-02-20 16:45:29.824  INFO 18700 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2020-02-20 16:45:29.898  INFO 18700 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 74 ms
2020-02-20 16:45:30.085  INFO 18700 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:45:30.522  WARN 18700 --- [http-nio-8080-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 16:45:30.608  WARN 18700 --- [http-nio-8080-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 16:45:30.991  INFO 18700 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:45:34.406  INFO 18700 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 16:45:34.478  INFO 18700 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 16:46:01.382  INFO 18700 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 16:46:01.457  INFO 18700 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 16:46:12.146  INFO 18700 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测试, {}]}
2020-02-20 16:46:12.147  INFO 18700 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 16:46:12.175 ERROR 18700 --- [http-nio-8080-exec-4] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-8080-exec-4] Exception processing template "searchResult": An error happened during template parsing (template: "class path resource [templates/searchResult.html]")

org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/searchResult.html]")
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:241)
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100)
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:667)
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1087)
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1061)
	at org.thymeleaf.spring4.view.ThymeleafView.renderFragment(ThymeleafView.java:335)
	at org.thymeleaf.spring4.view.ThymeleafView.render(ThymeleafView.java:189)
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1286)
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1041)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:984)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:635)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:742)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:745)
Caused by: org.attoparser.ParseException: Exception evaluating SpringEL expression: "#dates.format(blog.createTime, 'yyyy-MM-dd HH:mm:ss')" (template: "searchResult" - line 54, col 15)
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:393)
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257)
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230)
	... 52 common frames omitted
Caused by: org.thymeleaf.exceptions.TemplateProcessingException: Exception evaluating SpringEL expression: "#dates.format(blog.createTime, 'yyyy-MM-dd HH:mm:ss')" (template: "searchResult" - line 54, col 15)
	at org.thymeleaf.spring4.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:290)
	at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:165)
	at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66)
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109)
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138)
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:125)
	at org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:82)
	at org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74)
	at org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95)
	at org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633)
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314)
	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleOpenElementEnd(TemplateHandlerAdapterMarkupHandler.java:304)
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:278)
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.performInlining(OutputExpressionInlinePreProcessorHandler.java:440)
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleText(OutputExpressionInlinePreProcessorHandler.java:146)
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleText(InlinedOutputExpressionMarkupHandler.java:80)
	at org.attoparser.HtmlMarkupHandler.handleText(HtmlMarkupHandler.java:208)
	at org.attoparser.AbstractChainedMarkupHandler.handleText(AbstractChainedMarkupHandler.java:203)
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:662)
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301)
	... 54 common frames omitted
Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1007E: Property or field 'createTime' cannot be found on null
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:222)
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:94)
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:46)
	at org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:379)
	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:88)
	at org.springframework.expression.spel.ast.MethodReference.getArguments(MethodReference.java:155)
	at org.springframework.expression.spel.ast.MethodReference.getValueRef(MethodReference.java:72)
	at org.springframework.expression.spel.ast.CompoundExpression.getValueRef(CompoundExpression.java:66)
	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:87)
	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:121)
	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:324)
	at org.thymeleaf.spring4.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:263)
	... 73 common frames omitted

2020-02-20 16:46:12.178 ERROR 18700 --- [http-nio-8080-exec-4] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/searchResult.html]")] with root cause

org.springframework.expression.spel.SpelEvaluationException: EL1007E: Property or field 'createTime' cannot be found on null
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:222)
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:94)
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:46)
	at org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:379)
	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:88)
	at org.springframework.expression.spel.ast.MethodReference.getArguments(MethodReference.java:155)
	at org.springframework.expression.spel.ast.MethodReference.getValueRef(MethodReference.java:72)
	at org.springframework.expression.spel.ast.CompoundExpression.getValueRef(CompoundExpression.java:66)
	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:87)
	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:121)
	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:324)
	at org.thymeleaf.spring4.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:263)
	at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:165)
	at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66)
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109)
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138)
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:125)
	at org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:82)
	at org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74)
	at org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95)
	at org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633)
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314)
	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleOpenElementEnd(TemplateHandlerAdapterMarkupHandler.java:304)
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:278)
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.performInlining(OutputExpressionInlinePreProcessorHandler.java:440)
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleText(OutputExpressionInlinePreProcessorHandler.java:146)
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleText(InlinedOutputExpressionMarkupHandler.java:80)
	at org.attoparser.HtmlMarkupHandler.handleText(HtmlMarkupHandler.java:208)
	at org.attoparser.AbstractChainedMarkupHandler.handleText(AbstractChainedMarkupHandler.java:203)
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:662)
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301)
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257)
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230)
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100)
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:667)
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1087)
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1061)
	at org.thymeleaf.spring4.view.ThymeleafView.renderFragment(ThymeleafView.java:335)
	at org.thymeleaf.spring4.view.ThymeleafView.render(ThymeleafView.java:189)
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1286)
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1041)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:984)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:635)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:742)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:745)

2020-02-20 16:47:22.661  INFO 18700 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:47:22.902  INFO 18700 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:47:26.081  INFO 18700 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:47:26.100  INFO 18700 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:47:53.090  INFO 14548 --- [restartedMain] com.peng.blog.BlogApplication            : Starting BlogApplication on LAPTOP-3JGI280N with PID 14548 (D:\workspaces\ideaWebWorkSpace\blog\target\classes started by 23185 in D:\workspaces\ideaWebWorkSpace\blog)
2020-02-20 16:47:53.092 DEBUG 14548 --- [restartedMain] com.peng.blog.BlogApplication            : Running with Spring Boot v1.5.9.RELEASE, Spring v4.3.13.RELEASE
2020-02-20 16:47:53.092  INFO 14548 --- [restartedMain] com.peng.blog.BlogApplication            : The following profiles are active: dev
2020-02-20 16:47:53.539  INFO 14548 --- [restartedMain] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@3152bc: startup date [Thu Feb 20 16:47:53 CST 2020]; root of context hierarchy
2020-02-20 16:47:55.627  INFO 14548 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)
2020-02-20 16:47:55.636  INFO 14548 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-02-20 16:47:55.637  INFO 14548 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.23
2020-02-20 16:47:55.773  INFO 14548 --- [localhost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-02-20 16:47:55.774  INFO 14548 --- [localhost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 2235 ms
2020-02-20 16:47:56.037  INFO 14548 --- [localhost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/]
2020-02-20 16:47:56.042  INFO 14548 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*]
2020-02-20 16:47:56.043  INFO 14548 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
2020-02-20 16:47:56.043  INFO 14548 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*]
2020-02-20 16:47:56.043  INFO 14548 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*]
2020-02-20 16:47:58.309  INFO 14548 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit 'default'
2020-02-20 16:47:58.324  INFO 14548 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [
	name: default
	...]
2020-02-20 16:47:58.396  INFO 14548 --- [restartedMain] org.hibernate.Version                    : HHH000412: Hibernate Core {5.0.12.Final}
2020-02-20 16:47:58.398  INFO 14548 --- [restartedMain] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found
2020-02-20 16:47:58.399  INFO 14548 --- [restartedMain] org.hibernate.cfg.Environment            : HHH000021: Bytecode provider name : javassist
2020-02-20 16:47:58.439  INFO 14548 --- [restartedMain] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.0.1.Final}
2020-02-20 16:47:58.605  INFO 14548 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL5Dialect
2020-02-20 16:47:59.012  INFO 14548 --- [restartedMain] org.hibernate.tool.hbm2ddl.SchemaUpdate  : HHH000228: Running hbm2ddl schema update
2020-02-20 16:48:00.936  INFO 14548 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-02-20 16:48:01.236  INFO 14548 --- [restartedMain] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
2020-02-20 16:48:01.904  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@3152bc: startup date [Thu Feb 20 16:47:53 CST 2020]; root of context hierarchy
2020-02-20 16:48:01.966  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[ || /index.html],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.index(org.springframework.data.domain.Pageable,org.springframework.ui.Model)
2020-02-20 16:48:01.967  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/blog/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.check(int,org.springframework.ui.Model) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:48:01.967  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.client.BlogController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 16:48:01.968  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comments/{id}],methods=[GET]}" onto public java.util.List<com.peng.blog.entity.Comment> com.peng.blog.web.client.BlogController.comments(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:48:01.968  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/content/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.content(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:48:01.968  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/reply/{parent}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.reply(int,com.peng.blog.entity.Comment)
2020-02-20 16:48:01.968  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/searchPage],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.searchPage(java.lang.String,org.springframework.ui.Model)
2020-02-20 16:48:01.969  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/archive],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.archive(org.springframework.ui.Model)
2020-02-20 16:48:01.969  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comment/{blog}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.commentBlog(int,com.peng.blog.entity.Comment)
2020-02-20 16:48:01.970  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/tags],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TagClientController.showBlogByTag(com.peng.blog.utils.MyPage,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 16:48:01.970  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/types],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TypeClientController.showBlogsByType(org.springframework.data.domain.Pageable,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 16:48:01.972  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.add(com.peng.blog.entity.Blog,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:48:01.973  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog || /manage/blog/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.list(org.springframework.data.domain.Pageable,org.springframework.ui.Model,javax.servlet.http.HttpSession)
2020-02-20 16:48:01.974  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/search]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.search(org.springframework.data.domain.Pageable,com.peng.blog.entity.Blog,org.springframework.ui.Model)
2020-02-20 16:48:01.974  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/publish],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.publish(org.springframework.ui.Model,com.peng.blog.entity.Blog)
2020-02-20 16:48:01.975  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:48:01.975  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/del],methods=[GET]}" onto public com.peng.blog.utils.Message com.peng.blog.web.management.BlogManageController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:48:01.976  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/logout],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.LoginController.logout(javax.servlet.http.HttpSession)
2020-02-20 16:48:01.977  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/login],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.LoginController.login(java.lang.String,java.lang.String,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:48:01.981  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.add(com.peng.blog.entity.Tag,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:48:01.982  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag || /manage/tag/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.list(int,org.springframework.ui.Model)
2020-02-20 16:48:01.982  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 16:48:01.982  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:48:01.982  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:48:01.984  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.add(com.peng.blog.entity.Type,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:48:01.984  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/list || /manage/type],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.list(int,org.springframework.ui.Model)
2020-02-20 16:48:01.984  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 16:48:01.985  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:48:01.985  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 16:48:01.986  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t2]}" onto public java.lang.String com.peng.blog.web.TestController.t2(java.lang.String,int,boolean) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:48:01.986  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t1]}" onto public java.lang.String com.peng.blog.web.TestController.t1(java.lang.String) throws com.peng.blog.exception.NotFoundException
2020-02-20 16:48:01.986  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t3]}" onto public java.lang.String com.peng.blog.web.TestController.t3(int)
2020-02-20 16:48:01.987  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2020-02-20 16:48:01.988  INFO 14548 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error],produces=[text/html]}" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2020-02-20 16:48:02.015  INFO 14548 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/about] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:48:02.015  INFO 14548 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:48:02.015  INFO 14548 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/index.html] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:48:02.015  INFO 14548 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/welcome] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:48:02.016  INFO 14548 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/type/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:48:02.016  INFO 14548 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/tag/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 16:48:02.028  INFO 14548 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 16:48:02.029  INFO 14548 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 16:48:02.066  INFO 14548 --- [restartedMain] .m.m.a.ExceptionHandlerExceptionResolver : Detected @ExceptionHandler methods in globalExceptionHandler
2020-02-20 16:48:02.092  INFO 14548 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 16:48:02.369  INFO 14548 --- [restartedMain] oConfiguration$WelcomePageHandlerMapping : Adding welcome page: class path resource [static/index.html]
2020-02-20 16:48:02.799  INFO 14548 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-02-20 16:48:02.871  INFO 14548 --- [restartedMain] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2020-02-20 16:48:02.939  INFO 14548 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2020-02-20 16:48:02.947  INFO 14548 --- [restartedMain] com.peng.blog.BlogApplication            : Started BlogApplication in 10.584 seconds (JVM running for 12.487)
2020-02-20 16:48:19.071  INFO 14548 --- [http-nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2020-02-20 16:48:19.072  INFO 14548 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2020-02-20 16:48:19.132  INFO 14548 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 60 ms
2020-02-20 16:48:19.170  INFO 14548 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 16:48:19.520  WARN 14548 --- [http-nio-8080-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 16:48:19.567  WARN 14548 --- [http-nio-8080-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 16:48:19.609  INFO 14548 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 16:48:22.123  INFO 14548 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 16:48:22.180  INFO 14548 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 16:48:29.719  INFO 14548 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测试, {}]}
2020-02-20 16:48:29.719  INFO 14548 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 16:48:30.580  INFO 14548 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:48:30.613  INFO 14548 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:49:06.079  INFO 14548 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 1, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:49:06.233  INFO 14548 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:49:10.362  INFO 14548 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:49:10.394  INFO 14548 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:49:22.395  INFO 14548 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 1, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:49:22.420  INFO 14548 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:49:48.298  INFO 14548 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测试, {}]}
2020-02-20 16:49:48.298  INFO 14548 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 16:49:48.991  INFO 14548 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:49:49.021  INFO 14548 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:49:55.128  INFO 14548 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 16:49:55.160  INFO 14548 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 16:49:58.794  INFO 14548 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测试9, {}]}
2020-02-20 16:49:58.794  INFO 14548 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 16:49:59.026  INFO 14548 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试9, {}]}
2020-02-20 16:49:59.069  INFO 14548 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:50:11.584  INFO 14548 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/33', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.check', args=[33, {}]}
2020-02-20 16:50:12.415  INFO 14548 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 16:50:12.903  INFO 14548 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/33', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.content', args=[33]}
2020-02-20 16:50:12.907  INFO 14548 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/33', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[33]}
2020-02-20 16:50:12.941  INFO 14548 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:<i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i><i>测试9</i>
<table>
<tr><th>标题1</th><th>标题2</th></tr>
<tr><td>吱吱</td><td>呜呜</td></tr>
</table>
2020-02-20 16:50:13.586  INFO 14548 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:[]
2020-02-20 16:50:15.302  INFO 14548 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, 12]}
2020-02-20 16:50:15.351  INFO 14548 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 16:51:29.823  INFO 14548 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:51:29.840  INFO 14548 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:51:54.809  INFO 14548 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测试9, {}]}
2020-02-20 16:51:54.809  INFO 14548 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 16:51:55.288  INFO 14548 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:51:55.316  INFO 14548 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:52:04.065  INFO 14548 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测试9, {}]}
2020-02-20 16:52:04.066  INFO 14548 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 16:52:04.313  INFO 14548 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试9, {}]}
2020-02-20 16:52:04.346  INFO 14548 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:52:41.500  INFO 14548 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 16:52:41.530  INFO 14548 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 16:52:47.480  INFO 14548 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测试, {}]}
2020-02-20 16:52:47.481  INFO 14548 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 16:52:48.294  INFO 14548 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:52:48.311  INFO 14548 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:54:17.061  INFO 14548 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:54:17.076  INFO 14548 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:54:19.444  INFO 14548 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 1, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:54:19.459  INFO 14548 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:54:23.366  INFO 14548 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 1, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:54:23.385  INFO 14548 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:54:30.020  INFO 14548 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 16:54:30.040  INFO 14548 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 16:55:33.252  INFO 14548 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 16:55:33.292  INFO 14548 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 16:55:36.016  INFO 14548 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测, {}]}
2020-02-20 16:55:36.016  INFO 14548 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 16:55:36.634  INFO 14548 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测, {}]}
2020-02-20 16:55:36.653  INFO 14548 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:05:15.074  INFO 3732 --- [restartedMain] com.peng.blog.BlogApplication            : Starting BlogApplication on LAPTOP-3JGI280N with PID 3732 (D:\workspaces\ideaWebWorkSpace\blog\target\classes started by 23185 in D:\workspaces\ideaWebWorkSpace\blog)
2020-02-20 17:05:15.076 DEBUG 3732 --- [restartedMain] com.peng.blog.BlogApplication            : Running with Spring Boot v1.5.9.RELEASE, Spring v4.3.13.RELEASE
2020-02-20 17:05:15.076  INFO 3732 --- [restartedMain] com.peng.blog.BlogApplication            : The following profiles are active: dev
2020-02-20 17:05:15.375  INFO 3732 --- [restartedMain] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@39c07c5e: startup date [Thu Feb 20 17:05:15 CST 2020]; root of context hierarchy
2020-02-20 17:05:18.177  INFO 3732 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)
2020-02-20 17:05:18.189  INFO 3732 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-02-20 17:05:18.190  INFO 3732 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.23
2020-02-20 17:05:18.385  INFO 3732 --- [localhost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-02-20 17:05:18.386  INFO 3732 --- [localhost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 3011 ms
2020-02-20 17:05:18.860  INFO 3732 --- [localhost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/]
2020-02-20 17:05:18.870  INFO 3732 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*]
2020-02-20 17:05:18.871  INFO 3732 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
2020-02-20 17:05:18.871  INFO 3732 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*]
2020-02-20 17:05:18.872  INFO 3732 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*]
2020-02-20 17:05:21.001  INFO 3732 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit 'default'
2020-02-20 17:05:21.021  INFO 3732 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [
	name: default
	...]
2020-02-20 17:05:21.110  INFO 3732 --- [restartedMain] org.hibernate.Version                    : HHH000412: Hibernate Core {5.0.12.Final}
2020-02-20 17:05:21.112  INFO 3732 --- [restartedMain] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found
2020-02-20 17:05:21.113  INFO 3732 --- [restartedMain] org.hibernate.cfg.Environment            : HHH000021: Bytecode provider name : javassist
2020-02-20 17:05:21.155  INFO 3732 --- [restartedMain] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.0.1.Final}
2020-02-20 17:05:21.361  INFO 3732 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL5Dialect
2020-02-20 17:05:21.843  INFO 3732 --- [restartedMain] org.hibernate.tool.hbm2ddl.SchemaUpdate  : HHH000228: Running hbm2ddl schema update
2020-02-20 17:05:22.593  INFO 3732 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-02-20 17:05:22.911  INFO 3732 --- [restartedMain] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
2020-02-20 17:05:23.760  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@39c07c5e: startup date [Thu Feb 20 17:05:15 CST 2020]; root of context hierarchy
2020-02-20 17:05:23.847  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[ || /index.html],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.index(org.springframework.data.domain.Pageable,org.springframework.ui.Model)
2020-02-20 17:05:23.848  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/blog/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.check(int,org.springframework.ui.Model) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:05:23.848  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.client.BlogController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 17:05:23.848  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comments/{id}],methods=[GET]}" onto public java.util.List<com.peng.blog.entity.Comment> com.peng.blog.web.client.BlogController.comments(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:05:23.849  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/content/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.content(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:05:23.849  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/reply/{parent}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.reply(int,com.peng.blog.entity.Comment)
2020-02-20 17:05:23.849  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/searchPage],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.searchPage(java.lang.String,org.springframework.ui.Model)
2020-02-20 17:05:23.849  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/archive],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.archive(org.springframework.ui.Model)
2020-02-20 17:05:23.850  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comment/{blog}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.commentBlog(int,com.peng.blog.entity.Comment)
2020-02-20 17:05:23.850  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/tags],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TagClientController.showBlogByTag(com.peng.blog.utils.MyPage,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 17:05:23.851  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/types],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TypeClientController.showBlogsByType(org.springframework.data.domain.Pageable,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 17:05:23.852  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.add(com.peng.blog.entity.Blog,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:05:23.853  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog || /manage/blog/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.list(org.springframework.data.domain.Pageable,org.springframework.ui.Model,javax.servlet.http.HttpSession)
2020-02-20 17:05:23.853  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/search]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.search(org.springframework.data.domain.Pageable,com.peng.blog.entity.Blog,org.springframework.ui.Model)
2020-02-20 17:05:23.854  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/publish],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.publish(org.springframework.ui.Model,com.peng.blog.entity.Blog)
2020-02-20 17:05:23.855  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/del],methods=[GET]}" onto public com.peng.blog.utils.Message com.peng.blog.web.management.BlogManageController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:05:23.856  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:05:23.857  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/login],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.LoginController.login(java.lang.String,java.lang.String,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:05:23.858  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/logout],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.LoginController.logout(javax.servlet.http.HttpSession)
2020-02-20 17:05:23.863  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.add(com.peng.blog.entity.Tag,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:05:23.863  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag || /manage/tag/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.list(int,org.springframework.ui.Model)
2020-02-20 17:05:23.864  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 17:05:23.864  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:05:23.864  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:05:23.866  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.add(com.peng.blog.entity.Type,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:05:23.866  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/list || /manage/type],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.list(int,org.springframework.ui.Model)
2020-02-20 17:05:23.867  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 17:05:23.867  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:05:23.867  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:05:23.869  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t2]}" onto public java.lang.String com.peng.blog.web.TestController.t2(java.lang.String,int,boolean) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:05:23.869  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t1]}" onto public java.lang.String com.peng.blog.web.TestController.t1(java.lang.String) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:05:23.869  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t3]}" onto public java.lang.String com.peng.blog.web.TestController.t3(int)
2020-02-20 17:05:23.872  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2020-02-20 17:05:23.873  INFO 3732 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error],produces=[text/html]}" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2020-02-20 17:05:23.902  INFO 3732 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/about] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:05:23.902  INFO 3732 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:05:23.902  INFO 3732 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/index.html] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:05:23.902  INFO 3732 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/welcome] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:05:23.902  INFO 3732 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/type/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:05:23.903  INFO 3732 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/tag/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:05:23.916  INFO 3732 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 17:05:23.917  INFO 3732 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 17:05:23.942  INFO 3732 --- [restartedMain] .m.m.a.ExceptionHandlerExceptionResolver : Detected @ExceptionHandler methods in globalExceptionHandler
2020-02-20 17:05:23.966  INFO 3732 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 17:05:24.300  INFO 3732 --- [restartedMain] oConfiguration$WelcomePageHandlerMapping : Adding welcome page: class path resource [static/index.html]
2020-02-20 17:05:24.676  INFO 3732 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-02-20 17:05:24.745  INFO 3732 --- [restartedMain] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2020-02-20 17:05:24.821  INFO 3732 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2020-02-20 17:05:24.826  INFO 3732 --- [restartedMain] com.peng.blog.BlogApplication            : Started BlogApplication in 10.385 seconds (JVM running for 11.858)
2020-02-20 17:05:28.351  INFO 3732 --- [http-nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2020-02-20 17:05:28.352  INFO 3732 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2020-02-20 17:05:28.439  INFO 3732 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 87 ms
2020-02-20 17:05:28.495  INFO 3732 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 17:05:28.738  WARN 3732 --- [http-nio-8080-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 17:05:28.804  WARN 3732 --- [http-nio-8080-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 17:05:28.879  INFO 3732 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 17:05:33.307  INFO 3732 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:05:33.326  INFO 3732 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:05:37.348  INFO 3732 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 1, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:05:37.366  INFO 3732 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:05:39.893  INFO 3732 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:05:39.915  INFO 3732 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:05:41.218  INFO 3732 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 17:05:41.272  INFO 3732 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 17:05:45.310  INFO 3732 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测试, {}]}
2020-02-20 17:05:45.310  INFO 3732 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 17:05:46.016  INFO 3732 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:05:46.038  INFO 3732 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:05:52.783  INFO 3732 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 1, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:05:52.803  INFO 3732 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:05:56.929  INFO 3732 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='127.0.0.1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, null]}
2020-02-20 17:05:57.108  INFO 3732 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 17:06:00.136  INFO 3732 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测试, {}]}
2020-02-20 17:06:00.136  INFO 3732 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 17:06:00.860  INFO 3732 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:06:00.884  INFO 3732 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:06:04.731  INFO 3732 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 1, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:06:04.744  INFO 3732 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:06:07.572  INFO 3732 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/archive', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.archive', args=[{}]}
2020-02-20 17:06:07.588  INFO 3732 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:archive
2020-02-20 17:06:11.991  INFO 3732 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测试, {}]}
2020-02-20 17:06:11.992  INFO 3732 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 17:06:12.550  INFO 3732 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:06:12.578  INFO 3732 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:06:16.492  INFO 3732 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 1, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:06:16.508  INFO 3732 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:06:17.935  INFO 3732 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/25', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.check', args=[25, {}]}
2020-02-20 17:06:18.317  INFO 3732 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 17:06:18.679  INFO 3732 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/25', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.content', args=[25]}
2020-02-20 17:06:18.681  INFO 3732 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/25', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[25]}
2020-02-20 17:06:18.697  INFO 3732 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:#  H1
##  H2
###  H3
####  H4
#####  H5
######  H6
*斜体* or _强调_
**加粗** or __加粗__
***粗斜体*** or ___粗斜体__
Unordered 无序列表：
* 无序列表
* 子项
* 子项

Ordered 有序列表：
1. 第一行
2. 第二行
3. 第三行
2020-02-20 17:06:18.775  INFO 3732 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:[]
2020-02-20 17:06:21.848  INFO 3732 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测试, {}]}
2020-02-20 17:06:21.848  INFO 3732 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 17:06:22.120  INFO 3732 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:06:22.149  INFO 3732 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:06:27.197  INFO 3732 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 1, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:06:27.219  INFO 3732 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:06:31.914  INFO 3732 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测试, {}]}
2020-02-20 17:06:31.914  INFO 3732 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 17:06:32.153  INFO 3732 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:06:32.178  INFO 3732 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:06:34.175  INFO 3732 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 1, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:06:34.191  INFO 3732 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:07:11.485  INFO 3732 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试, {}]}
2020-02-20 17:07:11.507  INFO 3732 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:07:31.511  INFO 3732 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 17:07:31.731  INFO 3732 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 17:07:59.268  INFO 3732 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/archive', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.archive', args=[{}]}
2020-02-20 17:07:59.289  INFO 3732 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:archive
2020-02-20 17:08:07.486  INFO 3732 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/searchPage', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.searchPage', args=[测试111111111111, {}]}
2020-02-20 17:08:07.487  INFO 3732 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:searchResult
2020-02-20 17:08:08.049  INFO 3732 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.search', args=[Page request [number: 0, size 6, sort: createTime: DESC], 测试111111111111, {}]}
2020-02-20 17:08:08.060  INFO 3732 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:index:: leftContent
2020-02-20 17:31:42.129  INFO 4180 --- [restartedMain] com.peng.blog.BlogApplication            : Starting BlogApplication on LAPTOP-3JGI280N with PID 4180 (D:\workspaces\ideaWebWorkSpace\blog\target\classes started by 23185 in D:\workspaces\ideaWebWorkSpace\blog)
2020-02-20 17:31:42.131 DEBUG 4180 --- [restartedMain] com.peng.blog.BlogApplication            : Running with Spring Boot v1.5.9.RELEASE, Spring v4.3.13.RELEASE
2020-02-20 17:31:42.131  INFO 4180 --- [restartedMain] com.peng.blog.BlogApplication            : The following profiles are active: dev
2020-02-20 17:31:42.578  INFO 4180 --- [restartedMain] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@2c7c814e: startup date [Thu Feb 20 17:31:42 CST 2020]; root of context hierarchy
2020-02-20 17:31:44.912  INFO 4180 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)
2020-02-20 17:31:44.928  INFO 4180 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-02-20 17:31:44.928  INFO 4180 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.23
2020-02-20 17:31:45.144  INFO 4180 --- [localhost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-02-20 17:31:45.144  INFO 4180 --- [localhost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 2566 ms
2020-02-20 17:31:45.467  INFO 4180 --- [localhost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/]
2020-02-20 17:31:45.483  INFO 4180 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*]
2020-02-20 17:31:45.483  INFO 4180 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
2020-02-20 17:31:45.483  INFO 4180 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*]
2020-02-20 17:31:45.483  INFO 4180 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*]
2020-02-20 17:31:47.471  INFO 4180 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit 'default'
2020-02-20 17:31:47.487  INFO 4180 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [
	name: default
	...]
2020-02-20 17:31:47.534  INFO 4180 --- [restartedMain] org.hibernate.Version                    : HHH000412: Hibernate Core {5.0.12.Final}
2020-02-20 17:31:47.549  INFO 4180 --- [restartedMain] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found
2020-02-20 17:31:47.549  INFO 4180 --- [restartedMain] org.hibernate.cfg.Environment            : HHH000021: Bytecode provider name : javassist
2020-02-20 17:31:47.572  INFO 4180 --- [restartedMain] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.0.1.Final}
2020-02-20 17:31:47.719  INFO 4180 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL5Dialect
2020-02-20 17:31:48.320  INFO 4180 --- [restartedMain] org.hibernate.tool.hbm2ddl.SchemaUpdate  : HHH000228: Running hbm2ddl schema update
2020-02-20 17:31:48.837  INFO 4180 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-02-20 17:31:49.138  INFO 4180 --- [restartedMain] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
2020-02-20 17:31:49.871  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@2c7c814e: startup date [Thu Feb 20 17:31:42 CST 2020]; root of context hierarchy
2020-02-20 17:31:49.994  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[ || /index.html],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.index(org.springframework.data.domain.Pageable,org.springframework.ui.Model)
2020-02-20 17:31:50.009  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/blog/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.check(int,org.springframework.ui.Model) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:31:50.025  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.client.BlogController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 17:31:50.025  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comments/{id}],methods=[GET]}" onto public java.util.List<com.peng.blog.entity.Comment> com.peng.blog.web.client.BlogController.comments(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:31:50.025  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/content/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.content(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:31:50.025  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/reply/{parent}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.reply(int,com.peng.blog.entity.Comment)
2020-02-20 17:31:50.025  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/archive],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.archive(org.springframework.ui.Model)
2020-02-20 17:31:50.025  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comment/{blog}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.commentBlog(int,com.peng.blog.entity.Comment)
2020-02-20 17:31:50.040  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/searchPage],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.searchPage(java.lang.String,org.springframework.ui.Model)
2020-02-20 17:31:50.040  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/tags],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TagClientController.showBlogByTag(com.peng.blog.utils.MyPage,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 17:31:50.056  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/types],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TypeClientController.showBlogsByType(org.springframework.data.domain.Pageable,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 17:31:50.072  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.add(com.peng.blog.entity.Blog,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:31:50.080  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog || /manage/blog/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.list(org.springframework.data.domain.Pageable,org.springframework.ui.Model,javax.servlet.http.HttpSession)
2020-02-20 17:31:50.080  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/search]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.search(org.springframework.data.domain.Pageable,com.peng.blog.entity.Blog,org.springframework.ui.Model)
2020-02-20 17:31:50.080  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/publish],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.publish(org.springframework.ui.Model,com.peng.blog.entity.Blog)
2020-02-20 17:31:50.080  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/del],methods=[GET]}" onto public com.peng.blog.utils.Message com.peng.blog.web.management.BlogManageController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:31:50.090  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:31:50.090  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/login],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.LoginController.login(java.lang.String,java.lang.String,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:31:50.090  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/logout],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.LoginController.logout(javax.servlet.http.HttpSession)
2020-02-20 17:31:50.111  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.add(com.peng.blog.entity.Tag,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:31:50.111  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag || /manage/tag/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.list(int,org.springframework.ui.Model)
2020-02-20 17:31:50.111  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 17:31:50.111  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:31:50.119  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:31:50.121  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.add(com.peng.blog.entity.Type,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:31:50.121  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/list || /manage/type],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.list(int,org.springframework.ui.Model)
2020-02-20 17:31:50.121  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 17:31:50.121  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:31:50.121  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:31:50.121  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t2]}" onto public java.lang.String com.peng.blog.web.TestController.t2(java.lang.String,int,boolean) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:31:50.121  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t1]}" onto public java.lang.String com.peng.blog.web.TestController.t1(java.lang.String) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:31:50.121  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t3]}" onto public java.lang.String com.peng.blog.web.TestController.t3(int)
2020-02-20 17:31:50.129  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2020-02-20 17:31:50.129  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error],produces=[text/html]}" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2020-02-20 17:31:50.159  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/about] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:31:50.159  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:31:50.159  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/index.html] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:31:50.159  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/welcome] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:31:50.161  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/type/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:31:50.161  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/tag/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:31:50.181  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 17:31:50.181  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 17:31:50.201  INFO 4180 --- [restartedMain] .m.m.a.ExceptionHandlerExceptionResolver : Detected @ExceptionHandler methods in globalExceptionHandler
2020-02-20 17:31:50.221  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 17:31:50.496  INFO 4180 --- [restartedMain] oConfiguration$WelcomePageHandlerMapping : Adding welcome page: class path resource [static/index.html]
2020-02-20 17:31:50.924  INFO 4180 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-02-20 17:31:50.971  INFO 4180 --- [restartedMain] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2020-02-20 17:31:51.018  INFO 4180 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2020-02-20 17:31:51.033  INFO 4180 --- [restartedMain] com.peng.blog.BlogApplication            : Started BlogApplication in 9.826 seconds (JVM running for 12.52)
2020-02-20 17:32:19.449  INFO 4180 --- [http-nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2020-02-20 17:32:19.449  INFO 4180 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2020-02-20 17:32:19.495  INFO 4180 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 46 ms
2020-02-20 17:32:19.527  INFO 4180 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 17:32:19.777  WARN 4180 --- [http-nio-8080-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 17:32:19.839  WARN 4180 --- [http-nio-8080-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 17:32:19.886  INFO 4180 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 17:32:34.367  INFO 4180 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/login', ip='127.0.0.1', classMethod='com.peng.blog.web.management.LoginController.login', args=[peng, 123456, org.apache.catalina.session.StandardSessionFacade@4d34cb65, {}]}
2020-02-20 17:32:34.383  INFO 4180 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/welcome
2020-02-20 17:32:36.663  INFO 4180 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog', ip='127.0.0.1', classMethod='com.peng.blog.web.management.BlogManageController.list', args=[Page request [number: 0, size 5, sort: lastUpdateTime: DESC], {}, org.apache.catalina.session.StandardSessionFacade@4d34cb65]}
2020-02-20 17:32:36.726  INFO 4180 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:management/blogs
2020-02-20 17:32:56.815  INFO 4180 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 17:32:56.877  INFO 4180 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 17:33:01.954  INFO 4180 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/del', ip='127.0.0.1', classMethod='com.peng.blog.web.management.BlogManageController.del', args=[24, {}]}
2020-02-20 17:33:02.501  INFO 4180 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:Message{code=2, msg='标题为"测试2"的博客删除成功'}
2020-02-20 17:33:10.077  INFO 4180 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 17:33:10.171  INFO 4180 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 17:33:12.436  INFO 4180 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 17:33:12.498  INFO 4180 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 17:33:12.842  INFO 4180 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 17:33:12.951  INFO 4180 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 17:33:14.529  INFO 4180 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 17:33:14.592  INFO 4180 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 17:33:57.035  INFO 4180 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 1, size 6, sort: createTime: DESC], {}]}
2020-02-20 17:33:57.113  INFO 4180 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 17:34:04.799  INFO 4180 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 17:34:04.861  INFO 4180 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 17:34:18.249  INFO 4180 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/del', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.del', args=[31, {}]}
2020-02-20 17:34:18.514  WARN 4180 --- [http-nio-8080-exec-4] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 1451, SQLState: 23000
2020-02-20 17:34:18.514 ERROR 4180 --- [http-nio-8080-exec-4] o.h.engine.jdbc.spi.SqlExceptionHelper   : Cannot delete or update a parent row: a foreign key constraint fails (`blogtest2`.`t_comment`, CONSTRAINT `FKke3uogd04j4jx316m1p51e05u` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`))
2020-02-20 17:34:18.545  INFO 4180 --- [http-nio-8080-exec-4] o.h.e.j.b.internal.AbstractBatchImpl     : HHH000010: On release of batch it still contained JDBC statements
2020-02-20 17:34:18.623  INFO 4180 --- [http-nio-8080-exec-4] c.p.blog.handler.GlobalExceptionHandler  : 调用handleException方法
2020-02-20 17:34:18.623 ERROR 4180 --- [http-nio-8080-exec-4] c.p.blog.handler.GlobalExceptionHandler  : 抛出异常:org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement
2020-02-20 17:34:18.623  WARN 4180 --- [http-nio-8080-exec-4] .m.m.a.ExceptionHandlerExceptionResolver : Resolved exception caused by Handler execution: org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement
2020-02-20 17:35:11.548  INFO 4180 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/del', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.del', args=[33, {}]}
2020-02-20 17:35:11.861  INFO 4180 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:Message{code=2, msg='标题为"测试9"的博客删除成功'}
2020-02-20 17:35:23.793  INFO 4180 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 17:35:23.855  INFO 4180 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 17:36:06.132  INFO 4180 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/del', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.del', args=[31, {}]}
2020-02-20 17:36:06.288  WARN 4180 --- [http-nio-8080-exec-8] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 1451, SQLState: 23000
2020-02-20 17:36:06.288 ERROR 4180 --- [http-nio-8080-exec-8] o.h.engine.jdbc.spi.SqlExceptionHelper   : Cannot delete or update a parent row: a foreign key constraint fails (`blogtest2`.`t_comment`, CONSTRAINT `FKke3uogd04j4jx316m1p51e05u` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`))
2020-02-20 17:36:06.288  INFO 4180 --- [http-nio-8080-exec-8] o.h.e.j.b.internal.AbstractBatchImpl     : HHH000010: On release of batch it still contained JDBC statements
2020-02-20 17:36:06.398  INFO 4180 --- [http-nio-8080-exec-8] c.p.blog.handler.GlobalExceptionHandler  : 调用handleException方法
2020-02-20 17:36:06.398 ERROR 4180 --- [http-nio-8080-exec-8] c.p.blog.handler.GlobalExceptionHandler  : 抛出异常:org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement
2020-02-20 17:36:06.398  WARN 4180 --- [http-nio-8080-exec-8] .m.m.a.ExceptionHandlerExceptionResolver : Resolved exception caused by Handler execution: org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement
2020-02-20 17:36:11.084  INFO 4180 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/del', ip='127.0.0.1', classMethod='com.peng.blog.web.management.BlogManageController.del', args=[31, {}]}
2020-02-20 17:36:11.193  WARN 4180 --- [http-nio-8080-exec-9] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 1451, SQLState: 23000
2020-02-20 17:36:11.193 ERROR 4180 --- [http-nio-8080-exec-9] o.h.engine.jdbc.spi.SqlExceptionHelper   : Cannot delete or update a parent row: a foreign key constraint fails (`blogtest2`.`t_comment`, CONSTRAINT `FKke3uogd04j4jx316m1p51e05u` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`))
2020-02-20 17:36:11.193  INFO 4180 --- [http-nio-8080-exec-9] o.h.e.j.b.internal.AbstractBatchImpl     : HHH000010: On release of batch it still contained JDBC statements
2020-02-20 17:36:11.256  INFO 4180 --- [http-nio-8080-exec-9] c.p.blog.handler.GlobalExceptionHandler  : 调用handleException方法
2020-02-20 17:36:11.256 ERROR 4180 --- [http-nio-8080-exec-9] c.p.blog.handler.GlobalExceptionHandler  : 抛出异常:org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement
2020-02-20 17:36:11.272  WARN 4180 --- [http-nio-8080-exec-9] .m.m.a.ExceptionHandlerExceptionResolver : Resolved exception caused by Handler execution: org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement
2020-02-20 17:36:34.172  INFO 4180 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.list', args=[Page request [number: 0, size 5, sort: lastUpdateTime: DESC], {}, org.apache.catalina.session.StandardSessionFacade@4d34cb65]}
2020-02-20 17:36:34.204  INFO 4180 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:management/blogs
2020-02-20 17:36:38.000  INFO 4180 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/del', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.del', args=[31, {}]}
2020-02-20 17:36:38.015  WARN 4180 --- [http-nio-8080-exec-8] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 1451, SQLState: 23000
2020-02-20 17:36:38.015 ERROR 4180 --- [http-nio-8080-exec-8] o.h.engine.jdbc.spi.SqlExceptionHelper   : Cannot delete or update a parent row: a foreign key constraint fails (`blogtest2`.`t_comment`, CONSTRAINT `FKke3uogd04j4jx316m1p51e05u` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`))
2020-02-20 17:36:38.015  INFO 4180 --- [http-nio-8080-exec-8] o.h.e.j.b.internal.AbstractBatchImpl     : HHH000010: On release of batch it still contained JDBC statements
2020-02-20 17:36:38.172  INFO 4180 --- [http-nio-8080-exec-8] c.p.blog.handler.GlobalExceptionHandler  : 调用handleException方法
2020-02-20 17:36:38.172 ERROR 4180 --- [http-nio-8080-exec-8] c.p.blog.handler.GlobalExceptionHandler  : 抛出异常:org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement
2020-02-20 17:36:38.172  WARN 4180 --- [http-nio-8080-exec-8] .m.m.a.ExceptionHandlerExceptionResolver : Resolved exception caused by Handler execution: org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement
2020-02-20 17:38:02.198  INFO 4180 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 17:38:02.261  INFO 4180 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 17:38:04.245  INFO 4180 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 1, size 6, sort: createTime: DESC], {}]}
2020-02-20 17:38:04.307  INFO 4180 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 17:38:05.932  INFO 4180 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/31', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.check', args=[31, {}]}
2020-02-20 17:38:06.401  INFO 4180 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 17:38:06.791  INFO 4180 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/31', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.content', args=[31]}
2020-02-20 17:38:06.791  INFO 4180 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/31', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[31]}
2020-02-20 17:38:06.807  INFO 4180 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:# 测试7
**测试7**  
*测试7*
```java
System.out.println("Hello world!");
```
```css
*{
	margin:0;
	padding:0;
}
```
2020-02-20 17:38:07.229  INFO 4180 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:[Comment{id='26', content='7777777777777777777777', nickname='777', mail='789@qq.com', avatar='/images/headerImg.jpeg', publish_time=2020-02-17 23:18:35.0, childs=[Comment{id='27', content='88888', nickname='88888', mail='888', avatar='/images/headerImg.jpeg', publish_time=2020-02-17 23:18:41.0, childs=[]}]}]
2020-02-20 17:38:30.301  INFO 4180 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog', ip='127.0.0.1', classMethod='com.peng.blog.web.management.BlogManageController.list', args=[Page request [number: 0, size 5, sort: lastUpdateTime: DESC], {}, org.apache.catalina.session.StandardSessionFacade@4d34cb65]}
2020-02-20 17:38:30.426  INFO 4180 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:management/blogs
2020-02-20 17:38:32.441  INFO 4180 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/del', ip='127.0.0.1', classMethod='com.peng.blog.web.management.BlogManageController.del', args=[31, {}]}
2020-02-20 17:38:32.535  WARN 4180 --- [http-nio-8080-exec-5] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 1451, SQLState: 23000
2020-02-20 17:38:32.535 ERROR 4180 --- [http-nio-8080-exec-5] o.h.engine.jdbc.spi.SqlExceptionHelper   : Cannot delete or update a parent row: a foreign key constraint fails (`blogtest2`.`t_comment`, CONSTRAINT `FKke3uogd04j4jx316m1p51e05u` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`))
2020-02-20 17:38:32.535  INFO 4180 --- [http-nio-8080-exec-5] o.h.e.j.b.internal.AbstractBatchImpl     : HHH000010: On release of batch it still contained JDBC statements
2020-02-20 17:38:32.598  INFO 4180 --- [http-nio-8080-exec-5] c.p.blog.handler.GlobalExceptionHandler  : 调用handleException方法
2020-02-20 17:38:32.598 ERROR 4180 --- [http-nio-8080-exec-5] c.p.blog.handler.GlobalExceptionHandler  : 抛出异常:org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement
2020-02-20 17:38:32.598  WARN 4180 --- [http-nio-8080-exec-5] .m.m.a.ExceptionHandlerExceptionResolver : Resolved exception caused by Handler execution: org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement
2020-02-20 17:39:43.452  INFO 4180 --- [Thread-23] ationConfigEmbeddedWebApplicationContext : Closing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@2c7c814e: startup date [Thu Feb 20 17:31:42 CST 2020]; root of context hierarchy
2020-02-20 17:39:43.455  INFO 4180 --- [Thread-23] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown
2020-02-20 17:39:43.458  INFO 4180 --- [Thread-23] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'
2020-02-20 17:39:45.072  INFO 4180 --- [restartedMain] com.peng.blog.BlogApplication            : Starting BlogApplication on LAPTOP-3JGI280N with PID 4180 (D:\workspaces\ideaWebWorkSpace\blog\target\classes started by 23185 in D:\workspaces\ideaWebWorkSpace\blog)
2020-02-20 17:39:45.075 DEBUG 4180 --- [restartedMain] com.peng.blog.BlogApplication            : Running with Spring Boot v1.5.9.RELEASE, Spring v4.3.13.RELEASE
2020-02-20 17:39:45.078  INFO 4180 --- [restartedMain] com.peng.blog.BlogApplication            : The following profiles are active: dev
2020-02-20 17:39:45.083  INFO 4180 --- [restartedMain] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@19f3b46d: startup date [Thu Feb 20 17:39:45 CST 2020]; root of context hierarchy
2020-02-20 17:39:46.197  INFO 4180 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)
2020-02-20 17:39:46.198  INFO 4180 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-02-20 17:39:46.198  INFO 4180 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.23
2020-02-20 17:39:46.248  INFO 4180 --- [localhost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-02-20 17:39:46.249  INFO 4180 --- [localhost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1166 ms
2020-02-20 17:39:46.325  INFO 4180 --- [localhost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/]
2020-02-20 17:39:46.326  INFO 4180 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*]
2020-02-20 17:39:46.326  INFO 4180 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
2020-02-20 17:39:46.326  INFO 4180 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*]
2020-02-20 17:39:46.326  INFO 4180 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*]
2020-02-20 17:39:47.002  INFO 4180 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit 'default'
2020-02-20 17:39:47.002  INFO 4180 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [
	name: default
	...]
2020-02-20 17:39:47.088  INFO 4180 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL5Dialect
2020-02-20 17:39:47.160  INFO 4180 --- [restartedMain] org.hibernate.tool.hbm2ddl.SchemaUpdate  : HHH000228: Running hbm2ddl schema update
2020-02-20 17:39:47.744  INFO 4180 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-02-20 17:39:47.883  INFO 4180 --- [restartedMain] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
2020-02-20 17:39:48.318  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@19f3b46d: startup date [Thu Feb 20 17:39:45 CST 2020]; root of context hierarchy
2020-02-20 17:39:48.336  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[ || /index.html],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.index(org.springframework.data.domain.Pageable,org.springframework.ui.Model)
2020-02-20 17:39:48.337  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/blog/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.check(int,org.springframework.ui.Model) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:39:48.337  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.client.BlogController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 17:39:48.337  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comments/{id}],methods=[GET]}" onto public java.util.List<com.peng.blog.entity.Comment> com.peng.blog.web.client.BlogController.comments(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:39:48.338  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/content/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.content(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:39:48.338  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/reply/{parent}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.reply(int,com.peng.blog.entity.Comment)
2020-02-20 17:39:48.338  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/archive],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.archive(org.springframework.ui.Model)
2020-02-20 17:39:48.338  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comment/{blog}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.commentBlog(int,com.peng.blog.entity.Comment)
2020-02-20 17:39:48.338  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/searchPage],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.searchPage(java.lang.String,org.springframework.ui.Model)
2020-02-20 17:39:48.339  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/tags],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TagClientController.showBlogByTag(com.peng.blog.utils.MyPage,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 17:39:48.339  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/types],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TypeClientController.showBlogsByType(org.springframework.data.domain.Pageable,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 17:39:48.340  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.add(com.peng.blog.entity.Blog,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:39:48.340  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog || /manage/blog/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.list(org.springframework.data.domain.Pageable,org.springframework.ui.Model,javax.servlet.http.HttpSession)
2020-02-20 17:39:48.341  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/search]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.search(org.springframework.data.domain.Pageable,com.peng.blog.entity.Blog,org.springframework.ui.Model)
2020-02-20 17:39:48.341  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/publish],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.publish(org.springframework.ui.Model,com.peng.blog.entity.Blog)
2020-02-20 17:39:48.341  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/del],methods=[GET]}" onto public com.peng.blog.utils.Message com.peng.blog.web.management.BlogManageController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:39:48.341  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:39:48.342  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/login],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.LoginController.login(java.lang.String,java.lang.String,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:39:48.342  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/logout],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.LoginController.logout(javax.servlet.http.HttpSession)
2020-02-20 17:39:48.344  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.add(com.peng.blog.entity.Tag,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:39:48.345  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag || /manage/tag/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.list(int,org.springframework.ui.Model)
2020-02-20 17:39:48.345  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 17:39:48.345  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:39:48.345  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:39:48.346  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.add(com.peng.blog.entity.Type,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:39:48.346  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/list || /manage/type],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.list(int,org.springframework.ui.Model)
2020-02-20 17:39:48.346  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 17:39:48.347  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 17:39:48.347  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:39:48.347  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t2]}" onto public java.lang.String com.peng.blog.web.TestController.t2(java.lang.String,int,boolean) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:39:48.347  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t1]}" onto public java.lang.String com.peng.blog.web.TestController.t1(java.lang.String) throws com.peng.blog.exception.NotFoundException
2020-02-20 17:39:48.347  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t3]}" onto public java.lang.String com.peng.blog.web.TestController.t3(int)
2020-02-20 17:39:48.349  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2020-02-20 17:39:48.349  INFO 4180 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error],produces=[text/html]}" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2020-02-20 17:39:48.363  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/about] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:39:48.363  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:39:48.363  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/index.html] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:39:48.363  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/welcome] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:39:48.363  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/type/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:39:48.363  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/tag/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 17:39:48.370  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 17:39:48.370  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 17:39:48.384  INFO 4180 --- [restartedMain] .m.m.a.ExceptionHandlerExceptionResolver : Detected @ExceptionHandler methods in globalExceptionHandler
2020-02-20 17:39:48.392  INFO 4180 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 17:39:48.426  INFO 4180 --- [restartedMain] oConfiguration$WelcomePageHandlerMapping : Adding welcome page: class path resource [static/index.html]
2020-02-20 17:39:48.740  INFO 4180 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-02-20 17:39:48.801  INFO 4180 --- [restartedMain] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2020-02-20 17:39:48.827  INFO 4180 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2020-02-20 17:39:48.829  INFO 4180 --- [restartedMain] com.peng.blog.BlogApplication            : Started BlogApplication in 3.856 seconds (JVM running for 490.313)
2020-02-20 17:40:04.221  INFO 4180 --- [http-nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2020-02-20 17:40:04.221  INFO 4180 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2020-02-20 17:40:04.244  INFO 4180 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 23 ms
2020-02-20 17:40:04.255  INFO 4180 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/logout', ip='127.0.0.1', classMethod='com.peng.blog.web.management.LoginController.logout', args=[org.apache.catalina.session.StandardSessionFacade@3aa60505]}
2020-02-20 17:40:04.263  INFO 4180 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage
2020-02-20 17:40:08.836  INFO 4180 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/login', ip='127.0.0.1', classMethod='com.peng.blog.web.management.LoginController.login', args=[peng, 123456, org.apache.catalina.session.StandardSessionFacade@3aa60505, {}]}
2020-02-20 17:40:08.855  INFO 4180 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/welcome
2020-02-20 17:40:10.577  INFO 4180 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog', ip='127.0.0.1', classMethod='com.peng.blog.web.management.BlogManageController.list', args=[Page request [number: 0, size 5, sort: lastUpdateTime: DESC], {}, org.apache.catalina.session.StandardSessionFacade@3aa60505]}
2020-02-20 17:40:10.620  INFO 4180 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:management/blogs
2020-02-20 17:40:15.859  INFO 4180 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/del', ip='127.0.0.1', classMethod='com.peng.blog.web.management.BlogManageController.del', args=[31, {}]}
2020-02-20 17:40:16.146  INFO 4180 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:Message{code=2, msg='标题为"测试7"的博客删除成功'}
2020-02-20 17:40:52.770  INFO 4180 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/31', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.check', args=[31, {}]}
2020-02-20 17:40:52.882  INFO 4180 --- [http-nio-8080-exec-10] c.p.blog.handler.GlobalExceptionHandler  : 调用handleException方法
2020-02-20 17:40:52.882 ERROR 4180 --- [http-nio-8080-exec-10] c.p.blog.handler.GlobalExceptionHandler  : 抛出异常:com.peng.blog.exception.NotFoundException: 没有该博客
2020-02-20 17:40:52.884  INFO 4180 --- [http-nio-8080-exec-10] c.p.blog.handler.GlobalExceptionHandler  : com.peng.blog.exception.NotFoundException存在ResponseStatus注解
2020-02-20 17:40:52.884 ERROR 4180 --- [http-nio-8080-exec-10] c.p.blog.handler.GlobalExceptionHandler  : 状态码404，继续抛出异常由SpringBoot自己处理
2020-02-20 17:40:52.885  WARN 4180 --- [http-nio-8080-exec-10] .w.s.m.a.ResponseStatusExceptionResolver : Resolved exception caused by Handler execution: com.peng.blog.exception.NotFoundException: 没有该博客
2020-02-20 17:41:36.998  INFO 4180 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/26', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.check', args=[26, {}]}
2020-02-20 17:41:37.353  INFO 4180 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 17:41:37.717  INFO 4180 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/26', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.content', args=[26]}
2020-02-20 17:41:37.719  INFO 4180 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/26', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[26]}
2020-02-20 17:41:37.729  INFO 4180 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:Markdown 是一种轻量级标记语言，能将文本换成有效的XHTML(或者HTML)文档，它的目标是实现易读易写，成为一种适用于网络的书写语言。
2020-02-20 17:41:39.368  INFO 4180 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:[]
2020-02-20 17:41:43.505  INFO 4180 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comment/26', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.commentBlog', args=[26, Comment{id='null', content='111', nickname='111', mail='1111', avatar='', publish_time=null, childs=[]}]}
2020-02-20 17:41:43.985  INFO 4180 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:Comment{id='28', content='111', nickname='111', mail='1111', avatar='/images/headerImg.jpeg', publish_time=Thu Feb 20 17:41:43 CST 2020, childs=[]}
2020-02-20 17:41:48.024  INFO 4180 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/reply/28', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.reply', args=[28, Comment{id='null', content='2222', nickname='2222', mail='2222', avatar='', publish_time=null, childs=[]}]}
2020-02-20 17:41:48.188  INFO 4180 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:Comment{id='29', content='2222', nickname='2222', mail='2222', avatar='/images/headerImg.jpeg', publish_time=Thu Feb 20 17:41:48 CST 2020, childs=[]}
2020-02-20 17:41:54.253  INFO 4180 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/reply/29', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.reply', args=[29, Comment{id='null', content='3333', nickname='333', mail='3333', avatar='', publish_time=null, childs=[]}]}
2020-02-20 17:41:54.338  INFO 4180 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:Comment{id='30', content='3333', nickname='333', mail='3333', avatar='/images/headerImg.jpeg', publish_time=Thu Feb 20 17:41:54 CST 2020, childs=[]}
2020-02-20 17:42:01.837  INFO 4180 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/reply/30', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.reply', args=[30, Comment{id='null', content='4444', nickname='4444', mail='4444', avatar='', publish_time=null, childs=[]}]}
2020-02-20 17:42:02.027  INFO 4180 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:Comment{id='31', content='4444', nickname='4444', mail='4444', avatar='/images/headerImg.jpeg', publish_time=Thu Feb 20 17:42:01 CST 2020, childs=[]}
2020-02-20 17:42:27.418  INFO 4180 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog', ip='127.0.0.1', classMethod='com.peng.blog.web.management.BlogManageController.list', args=[Page request [number: 1, size 5, sort: lastUpdateTime: DESC], {}, org.apache.catalina.session.StandardSessionFacade@3aa60505]}
2020-02-20 17:42:27.460  INFO 4180 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:management/blogs
2020-02-20 17:42:33.990  INFO 4180 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/del', ip='127.0.0.1', classMethod='com.peng.blog.web.management.BlogManageController.del', args=[26, {}]}
2020-02-20 17:42:34.207  INFO 4180 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:Message{code=2, msg='标题为"测试4"的博客删除成功'}
2020-02-20 19:44:31.326  INFO 16572 --- [restartedMain] com.peng.blog.BlogApplication            : Starting BlogApplication on LAPTOP-3JGI280N with PID 16572 (D:\workspaces\ideaWebWorkSpace\blog\target\classes started by 23185 in D:\workspaces\ideaWebWorkSpace\blog)
2020-02-20 19:44:31.326 DEBUG 16572 --- [restartedMain] com.peng.blog.BlogApplication            : Running with Spring Boot v1.5.9.RELEASE, Spring v4.3.13.RELEASE
2020-02-20 19:44:31.326  INFO 16572 --- [restartedMain] com.peng.blog.BlogApplication            : The following profiles are active: dev
2020-02-20 19:44:31.987  INFO 16572 --- [restartedMain] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@5c80e338: startup date [Thu Feb 20 19:44:31 CST 2020]; root of context hierarchy
2020-02-20 19:44:39.699  INFO 16572 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)
2020-02-20 19:44:39.715  INFO 16572 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-02-20 19:44:39.717  INFO 16572 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.23
2020-02-20 19:44:40.034  INFO 16572 --- [localhost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-02-20 19:44:40.035  INFO 16572 --- [localhost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 8048 ms
2020-02-20 19:44:40.432  INFO 16572 --- [localhost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/]
2020-02-20 19:44:40.437  INFO 16572 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*]
2020-02-20 19:44:40.438  INFO 16572 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
2020-02-20 19:44:40.442  INFO 16572 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*]
2020-02-20 19:44:40.445  INFO 16572 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*]
2020-02-20 19:44:42.072  INFO 16572 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit 'default'
2020-02-20 19:44:42.105  INFO 16572 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [
	name: default
	...]
2020-02-20 19:44:42.246  INFO 16572 --- [restartedMain] org.hibernate.Version                    : HHH000412: Hibernate Core {5.0.12.Final}
2020-02-20 19:44:42.249  INFO 16572 --- [restartedMain] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found
2020-02-20 19:44:42.250  INFO 16572 --- [restartedMain] org.hibernate.cfg.Environment            : HHH000021: Bytecode provider name : javassist
2020-02-20 19:44:42.329  INFO 16572 --- [restartedMain] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.0.1.Final}
2020-02-20 19:44:42.644  INFO 16572 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL5Dialect
2020-02-20 19:44:43.380  INFO 16572 --- [restartedMain] org.hibernate.tool.hbm2ddl.SchemaUpdate  : HHH000228: Running hbm2ddl schema update
2020-02-20 19:44:43.858  INFO 16572 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-02-20 19:44:44.222  INFO 16572 --- [restartedMain] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
2020-02-20 19:44:45.099  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@5c80e338: startup date [Thu Feb 20 19:44:31 CST 2020]; root of context hierarchy
2020-02-20 19:44:45.179  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[ || /index.html],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.index(org.springframework.data.domain.Pageable,org.springframework.ui.Model)
2020-02-20 19:44:45.180  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/blog/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.check(int,org.springframework.ui.Model) throws com.peng.blog.exception.NotFoundException
2020-02-20 19:44:45.181  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.client.BlogController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 19:44:45.181  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comments/{id}],methods=[GET]}" onto public java.util.List<com.peng.blog.entity.Comment> com.peng.blog.web.client.BlogController.comments(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 19:44:45.181  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/content/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.content(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 19:44:45.182  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/reply/{parent}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.reply(int,com.peng.blog.entity.Comment)
2020-02-20 19:44:45.182  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comment/{blog}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.commentBlog(int,com.peng.blog.entity.Comment)
2020-02-20 19:44:45.182  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/searchPage],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.searchPage(java.lang.String,org.springframework.ui.Model)
2020-02-20 19:44:45.183  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/archive],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.archive(org.springframework.ui.Model)
2020-02-20 19:44:45.184  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/tags],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TagClientController.showBlogByTag(com.peng.blog.utils.MyPage,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 19:44:45.185  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/types],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TypeClientController.showBlogsByType(org.springframework.data.domain.Pageable,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 19:44:45.187  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.add(com.peng.blog.entity.Blog,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 19:44:45.188  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog || /manage/blog/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.list(org.springframework.data.domain.Pageable,org.springframework.ui.Model,javax.servlet.http.HttpSession)
2020-02-20 19:44:45.188  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/search]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.search(org.springframework.data.domain.Pageable,com.peng.blog.entity.Blog,org.springframework.ui.Model)
2020-02-20 19:44:45.189  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/publish],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.publish(org.springframework.ui.Model,com.peng.blog.entity.Blog)
2020-02-20 19:44:45.189  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 19:44:45.190  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/del],methods=[GET]}" onto public com.peng.blog.utils.Message com.peng.blog.web.management.BlogManageController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 19:44:45.191  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/logout],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.LoginController.logout(javax.servlet.http.HttpSession)
2020-02-20 19:44:45.192  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/login],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.LoginController.login(java.lang.String,java.lang.String,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 19:44:45.196  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.add(com.peng.blog.entity.Tag,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 19:44:45.197  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag || /manage/tag/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.list(int,org.springframework.ui.Model)
2020-02-20 19:44:45.198  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 19:44:45.198  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 19:44:45.198  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 19:44:45.200  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.add(com.peng.blog.entity.Type,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 19:44:45.202  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/list || /manage/type],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.list(int,org.springframework.ui.Model)
2020-02-20 19:44:45.202  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 19:44:45.203  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 19:44:45.204  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 19:44:45.206  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t2]}" onto public java.lang.String com.peng.blog.web.TestController.t2(java.lang.String,int,boolean) throws com.peng.blog.exception.NotFoundException
2020-02-20 19:44:45.206  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t1]}" onto public java.lang.String com.peng.blog.web.TestController.t1(java.lang.String) throws com.peng.blog.exception.NotFoundException
2020-02-20 19:44:45.206  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t3]}" onto public java.lang.String com.peng.blog.web.TestController.t3(int)
2020-02-20 19:44:45.209  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2020-02-20 19:44:45.209  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error],produces=[text/html]}" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2020-02-20 19:44:45.243  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/about] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 19:44:45.243  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 19:44:45.243  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/index.html] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 19:44:45.244  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/welcome] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 19:44:45.244  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/type/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 19:44:45.244  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/tag/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 19:44:45.258  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 19:44:45.258  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 19:44:45.279  INFO 16572 --- [restartedMain] .m.m.a.ExceptionHandlerExceptionResolver : Detected @ExceptionHandler methods in globalExceptionHandler
2020-02-20 19:44:45.304  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 19:44:45.710  INFO 16572 --- [restartedMain] oConfiguration$WelcomePageHandlerMapping : Adding welcome page: class path resource [static/index.html]
2020-02-20 19:44:46.415  INFO 16572 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-02-20 19:44:46.535  INFO 16572 --- [restartedMain] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2020-02-20 19:44:46.691  INFO 16572 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2020-02-20 19:44:46.699  INFO 16572 --- [restartedMain] com.peng.blog.BlogApplication            : Started BlogApplication in 16.419 seconds (JVM running for 20.98)
2020-02-20 19:46:08.941  INFO 16572 --- [http-nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2020-02-20 19:46:08.942  INFO 16572 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2020-02-20 19:46:09.156  INFO 16572 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 214 ms
2020-02-20 19:46:16.538  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/login', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.LoginController.login', args=[peng, 123456, org.apache.catalina.session.StandardSessionFacade@4ee0cd09, {}]}
2020-02-20 19:46:16.718  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/welcome
2020-02-20 19:46:18.167  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.list', args=[Page request [number: 0, size 5, sort: lastUpdateTime: DESC], {}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09]}
2020-02-20 19:46:18.278  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:management/blogs
2020-02-20 19:46:19.188  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/type', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TypeController.list', args=[0, {}]}
2020-02-20 19:46:19.218  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:management/manageType
2020-02-20 19:46:26.818  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/type/search', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TypeController.search', args=[Page request [number: 0, size 5, sort: null], SpringBoot, {}]}
2020-02-20 19:46:26.931  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:management/manageType :: table
2020-02-20 19:46:36.841  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/type/search', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TypeController.search', args=[Page request [number: 0, size 5, sort: null], spring, {}]}
2020-02-20 19:46:36.850  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:management/manageType :: table
2020-02-20 19:46:40.897  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/type', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TypeController.list', args=[0, {}]}
2020-02-20 19:46:40.912  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:management/manageType
2020-02-20 19:47:14.430  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/type', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TypeController.list', args=[0, {}]}
2020-02-20 19:47:14.443  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:management/manageType
2020-02-20 19:47:19.550  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/type/search', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TypeController.search', args=[Page request [number: 0, size 5, sort: null], ce, {}]}
2020-02-20 19:47:19.558  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:management/manageType :: table
2020-02-20 19:47:22.929  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/type/search', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TypeController.search', args=[Page request [number: 0, size 5, sort: null], 测试, {}]}
2020-02-20 19:47:22.941  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:management/manageType :: table
2020-02-20 19:47:25.936  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/type', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TypeController.list', args=[0, {}]}
2020-02-20 19:47:25.944  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:management/manageType
2020-02-20 19:47:39.332  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/type/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TypeController.add', args=[Type{id='null', name=Java进阶}, {}]}
2020-02-20 19:47:39.563  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/type/publish
2020-02-20 19:47:41.801  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/type', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TypeController.list', args=[0, {}]}
2020-02-20 19:47:41.815  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:management/manageType
2020-02-20 19:47:43.530  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/tag', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TagController.list', args=[0, {}]}
2020-02-20 19:47:43.549  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:management/manageTag
2020-02-20 19:47:55.147  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/tag/search', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TagController.search', args=[Page request [number: 0, size 5, sort: null], spring, {}]}
2020-02-20 19:47:55.164  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:management/manageTag :: table
2020-02-20 19:48:00.270  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/tag/search', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TagController.search', args=[Page request [number: 0, size 5, sort: null], spring, {}]}
2020-02-20 19:48:00.278  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:management/manageTag :: table
2020-02-20 19:48:19.831  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/tag/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.TagController.add', args=[Tag{id='null', name='类加载器'}, {}]}
2020-02-20 19:48:20.049  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/tag/publish
2020-02-20 19:48:22.357  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.list', args=[Page request [number: 0, size 5, sort: lastUpdateTime: DESC], {}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09]}
2020-02-20 19:48:22.391  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:management/blogs
2020-02-20 19:48:23.598  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{blog=Blog{id='null', title='null', content='null', original=null, recommend_toggle=false, share_toggle=false, appreciate_toggle=false, comment_toggle=false, publish_toggle=false, picture_addr='null', description='null', createTime=null, lastUpdateTime=null, view_times=0, type=null, tags=[], user=null, tagIds='null'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='null', title='null', content='null', original=null, recommend_toggle=false, share_toggle=false, appreciate_toggle=false, comment_toggle=false, publish_toggle=false, picture_addr='null', description='null', createTime=null, lastUpdateTime=null, view_times=0, type=null, tags=[], user=null, tagIds='null'}]}
2020-02-20 19:48:23.663  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 19:49:03.445  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.list', args=[Page request [number: 0, size 5, sort: lastUpdateTime: DESC], {}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09]}
2020-02-20 19:49:03.515  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:management/blogs
2020-02-20 19:49:09.578  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/edit', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.edit', args=[30, {}]}
2020-02-20 19:49:09.595  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 19:49:09.611  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{blog=Blog{id='30', title='Markdown基本语法学习', content='# 一、Markdown 是什么？
Markdown 是一种**轻量级的**「**标记语言**」，创始人为约翰·格鲁伯，用简洁的语法代替排版，目前被越来越多的知识工作者、写作爱好者、程序员或研究员广泛使用。其常用的标记符号不超过十个，相对于更为复杂的 HTML 标记语言来说，Markdown 十分的轻量，学习成本也不需要太多，且一旦熟悉这种语法规则，会有沉浸式编辑的效果。

# 二、Markdown 有什么特点？

 - 一键创建：支持 Markdown 独立的一键新建入口，为深度 Markdown 用户提供更好的效率体验；
 - 支持丰富的主流 Markdown 语法：支持文字相关样式、序号列表、任务列表、表格、TOC 目录、多种图表、数学公式、流程图、时序图、甘特图等；
 - 支持插入图片：可插入网络图片 或 直接拖动本地图片、复制剪贴板中的图片到 Markdown 笔记中；
 - 支持多种模式切换：编辑与预览模式、纯编辑模式以及纯预览模式；
 - 支持多种编辑主题：预置了白色、黑色、深空灰和印象绿主题，默认为印象绿，未来会有更多主题提供；
 - 跨平台同步：创建的 Markdown 笔记可在登录了印象笔记帐户的各端查看，未来更多端会支持创建和编辑 Markdown 笔记；
 - 演示模式：Markdown 笔记支持演示模式查看；
 - 支持其他印象笔记特点功能：笔记标注、导出 PDF、设置提醒、工作群聊共享-查看&编辑笔记等。

# 三、如何创建 Markdown 笔记？

 - 点击左上角「新建 Markdown 笔记」来创建新的 Markdown 笔记，另外，也支持配置隐藏「新建 Markdown 笔记」按钮，Windows 用户直接右单击「新建 Markdown 笔记」按钮，即可隐藏，Mac 用户可以右单击左侧边栏空白处，取消勾选「新建 Markdown 笔记」来完成隐藏此按钮
 - 点击菜单栏-文件-新建笔记-新建 Markdown 笔记（Mac 上为顶部菜单栏-文件-新建 Markdown笔记）
 - 使用快捷键 Ctrl+alt+D（Mac 上 CMD+D）来快速创建 Markdown 笔记

# 四、印象笔记 Markdown 笔记支持哪些语法？

- \# 设置分级标题（最多6级标题）
- \*\*加粗\*\*，效果：**加粗**
- \*斜体样式\*，效果：*斜体*
- \<u>下划线\</u>，效果：<u>下划线</u>
- \~\~删除线\~\~，效果：~~删除线~~
- \>引用文本，效果：

 > 这里是引用

- 添加代办事项，效果：
 三只青蛙：
 * [x] 第一
 * [ ] 第二
 * [ ] 第三  
- 插入链接：\[名称\]\(链接地址\)
 [百度官网](http://www.baidu.com)
- 插入图片：\!\[图片描述\]\(图片地址\)
![罗宾](https://img-blog.csdnimg.cn/20200215203947531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA1NTU1,size_16,color_FFFFFF,t_70)
- 插入表格：  
 1.语法：  
| 标题一 | 标题二 |  
|-\-|-\-|  
| 值1 | 值2|  
 2.效果：  

| 标题一 | 标题二 |
|--|--|
| 值1 | 值2|

- 插入Java代码块：  
 1.语法:  
  \~\~\~java  
  插入代码  
  \~\~\~  
 2.效果  
 ```java
 System.out.println("Hello world!");
 ```
', original=0, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='Markdown 是一种轻量级的「标记语言」，创始人为约翰·格鲁伯，用简洁的语法代替排版，目前被越来越多的知识工作者、写作爱好者、程序员或研究员广泛使用。其常用的标记符号不超过十个，相对于更为复杂的 HTML 标记语言来说，Markdown 十分的轻量，学习成本也不需要太多，且一旦熟悉这种语法规则，会有沉浸式编辑的效果', createTime=2020-02-15 20:56:42.0, lastUpdateTime=2020-02-16 18:55:47.0, view_times=64, type=Type{id='53', name=各类工具学习}, tags=[Tag{id='17', name='Markdown的使用'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='17'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='30', title='Markdown基本语法学习', content='# 一、Markdown 是什么？
Markdown 是一种**轻量级的**「**标记语言**」，创始人为约翰·格鲁伯，用简洁的语法代替排版，目前被越来越多的知识工作者、写作爱好者、程序员或研究员广泛使用。其常用的标记符号不超过十个，相对于更为复杂的 HTML 标记语言来说，Markdown 十分的轻量，学习成本也不需要太多，且一旦熟悉这种语法规则，会有沉浸式编辑的效果。

# 二、Markdown 有什么特点？

 - 一键创建：支持 Markdown 独立的一键新建入口，为深度 Markdown 用户提供更好的效率体验；
 - 支持丰富的主流 Markdown 语法：支持文字相关样式、序号列表、任务列表、表格、TOC 目录、多种图表、数学公式、流程图、时序图、甘特图等；
 - 支持插入图片：可插入网络图片 或 直接拖动本地图片、复制剪贴板中的图片到 Markdown 笔记中；
 - 支持多种模式切换：编辑与预览模式、纯编辑模式以及纯预览模式；
 - 支持多种编辑主题：预置了白色、黑色、深空灰和印象绿主题，默认为印象绿，未来会有更多主题提供；
 - 跨平台同步：创建的 Markdown 笔记可在登录了印象笔记帐户的各端查看，未来更多端会支持创建和编辑 Markdown 笔记；
 - 演示模式：Markdown 笔记支持演示模式查看；
 - 支持其他印象笔记特点功能：笔记标注、导出 PDF、设置提醒、工作群聊共享-查看&编辑笔记等。

# 三、如何创建 Markdown 笔记？

 - 点击左上角「新建 Markdown 笔记」来创建新的 Markdown 笔记，另外，也支持配置隐藏「新建 Markdown 笔记」按钮，Windows 用户直接右单击「新建 Markdown 笔记」按钮，即可隐藏，Mac 用户可以右单击左侧边栏空白处，取消勾选「新建 Markdown 笔记」来完成隐藏此按钮
 - 点击菜单栏-文件-新建笔记-新建 Markdown 笔记（Mac 上为顶部菜单栏-文件-新建 Markdown笔记）
 - 使用快捷键 Ctrl+alt+D（Mac 上 CMD+D）来快速创建 Markdown 笔记

# 四、印象笔记 Markdown 笔记支持哪些语法？

- \# 设置分级标题（最多6级标题）
- \*\*加粗\*\*，效果：**加粗**
- \*斜体样式\*，效果：*斜体*
- \<u>下划线\</u>，效果：<u>下划线</u>
- \~\~删除线\~\~，效果：~~删除线~~
- \>引用文本，效果：

 > 这里是引用

- 添加代办事项，效果：
 三只青蛙：
 * [x] 第一
 * [ ] 第二
 * [ ] 第三  
- 插入链接：\[名称\]\(链接地址\)
 [百度官网](http://www.baidu.com)
- 插入图片：\!\[图片描述\]\(图片地址\)
![罗宾](https://img-blog.csdnimg.cn/20200215203947531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA1NTU1,size_16,color_FFFFFF,t_70)
- 插入表格：  
 1.语法：  
| 标题一 | 标题二 |  
|-\-|-\-|  
| 值1 | 值2|  
 2.效果：  

| 标题一 | 标题二 |
|--|--|
| 值1 | 值2|

- 插入Java代码块：  
 1.语法:  
  \~\~\~java  
  插入代码  
  \~\~\~  
 2.效果  
 ```java
 System.out.println("Hello world!");
 ```
', original=0, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='Markdown 是一种轻量级的「标记语言」，创始人为约翰·格鲁伯，用简洁的语法代替排版，目前被越来越多的知识工作者、写作爱好者、程序员或研究员广泛使用。其常用的标记符号不超过十个，相对于更为复杂的 HTML 标记语言来说，Markdown 十分的轻量，学习成本也不需要太多，且一旦熟悉这种语法规则，会有沉浸式编辑的效果', createTime=2020-02-15 20:56:42.0, lastUpdateTime=2020-02-16 18:55:47.0, view_times=64, type=Type{id='53', name=各类工具学习}, tags=[Tag{id='17', name='Markdown的使用'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='17'}]}
2020-02-20 19:49:09.681  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:05:21.704  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.add', args=[Blog{id='null', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  
### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    
### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  
### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=null, lastUpdateTime=null, view_times=0, type=Type{id='56', name=null}, tags=[], user=null, tagIds='18'}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09, {}]}
2020-02-20 20:05:22.088  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:05:22.101  INFO 16572 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{message=Message{code=1, msg='标题为"jvm之java类加载机制和类加载器(ClassLoader)的详解"的博客添加成功。
您可以继续编辑修改博客。'}, blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  
### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    
### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  
### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=Thu Feb 20 20:05:21 CST 2020, lastUpdateTime=Thu Feb 20 20:05:21 CST 2020, view_times=0, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='null', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  
### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    
### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  
### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=Thu Feb 20 20:05:21 CST 2020, lastUpdateTime=Thu Feb 20 20:05:21 CST 2020, view_times=0, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='null', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:05:22.205  INFO 16572 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:05:30.266  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.add', args=[Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  
### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    
### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  
### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=false, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=null, lastUpdateTime=null, view_times=0, type=Type{id='56', name=null}, tags=[], user=null, tagIds='18'}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09, {}]}
2020-02-20 20:05:30.650  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:05:30.668  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{message=Message{code=1, msg='标题为"jvm之java类加载机制和类加载器(ClassLoader)的详解"的博客更新成功。
您可以继续编辑修改博客。'}, blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  
### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    
### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  
### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=false, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:05:30 CST 2020, view_times=0, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  
### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    
### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  
### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=false, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:05:30 CST 2020, view_times=0, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:05:30.766  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:05:41.120  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 20:05:41.146  WARN 16572 --- [http-nio-8080-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 20:05:41.183  WARN 16572 --- [http-nio-8080-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 20:05:41.225  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 20:05:42.571  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 20:05:42.668  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 20:05:44.790  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.add', args=[Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  
### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    
### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  
### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=null, lastUpdateTime=null, view_times=0, type=Type{id='56', name=null}, tags=[], user=null, tagIds='18'}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09, {}]}
2020-02-20 20:05:44.987  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:05:45.035  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{message=Message{code=1, msg='标题为"jvm之java类加载机制和类加载器(ClassLoader)的详解"的博客更新成功。
您可以继续编辑修改博客。'}, blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  
### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    
### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  
### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:05:44 CST 2020, view_times=0, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  
### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    
### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  
### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:05:44 CST 2020, view_times=0, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:05:45.140  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:05:47.382  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 20:05:47.441  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 20:05:48.543  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.check', args=[36, {}]}
2020-02-20 20:05:48.733  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 20:05:49.055  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.content', args=[36]}
2020-02-20 20:05:49.056  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[36]}
2020-02-20 20:05:49.070  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  
### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    
### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  
### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349






2020-02-20 20:05:49.285  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:[]
2020-02-20 20:07:14.020  INFO 16572 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.add', args=[Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=null, lastUpdateTime=null, view_times=0, type=Type{id='56', name=null}, tags=[], user=null, tagIds='18'}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09, {}]}
2020-02-20 20:07:14.274  INFO 16572 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:07:14.284  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{message=Message{code=1, msg='标题为"jvm之java类加载机制和类加载器(ClassLoader)的详解"的博客更新成功。
您可以继续编辑修改博客。'}, blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:07:14 CST 2020, view_times=1, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:07:14 CST 2020, view_times=1, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:07:14.347  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:07:17.284  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.check', args=[36, {}]}
2020-02-20 20:07:17.393  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 20:07:17.891  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.content', args=[36]}
2020-02-20 20:07:17.894  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[36]}
2020-02-20 20:07:17.904  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  
#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349






2020-02-20 20:07:17.917  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:[]
2020-02-20 20:07:38.180  INFO 16572 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.add', args=[Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=null, lastUpdateTime=null, view_times=0, type=Type{id='56', name=null}, tags=[], user=null, tagIds='18'}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09, {}]}
2020-02-20 20:07:38.324  INFO 16572 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:07:38.341  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{message=Message{code=1, msg='标题为"jvm之java类加载机制和类加载器(ClassLoader)的详解"的博客更新成功。
您可以继续编辑修改博客。'}, blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:07:38 CST 2020, view_times=2, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:07:38 CST 2020, view_times=2, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:07:38.408  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:07:41.736  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.add', args=[Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=false, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=null, lastUpdateTime=null, view_times=0, type=Type{id='56', name=null}, tags=[], user=null, tagIds='18'}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09, {}]}
2020-02-20 20:07:41.922  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:07:41.933  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{message=Message{code=1, msg='标题为"jvm之java类加载机制和类加载器(ClassLoader)的详解"的博客更新成功。
您可以继续编辑修改博客。'}, blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=false, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:07:41 CST 2020, view_times=2, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=false, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:07:41 CST 2020, view_times=2, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:07:42.066  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:07:47.352  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.check', args=[36, {}]}
2020-02-20 20:07:47.527  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 20:07:48.137  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.content', args=[36]}
2020-02-20 20:07:48.140  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[36]}
2020-02-20 20:07:48.151  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349






2020-02-20 20:07:48.163  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:[]
2020-02-20 20:07:51.294  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.add', args=[Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=null, lastUpdateTime=null, view_times=0, type=Type{id='56', name=null}, tags=[], user=null, tagIds='18'}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09, {}]}
2020-02-20 20:07:51.427  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:07:51.436  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{message=Message{code=1, msg='标题为"jvm之java类加载机制和类加载器(ClassLoader)的详解"的博客更新成功。
您可以继续编辑修改博客。'}, blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:07:51 CST 2020, view_times=3, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:07:51 CST 2020, view_times=3, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:07:51.535  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:08:02.198  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.check', args=[36, {}]}
2020-02-20 20:08:02.393  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 20:08:02.843  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.content', args=[36]}
2020-02-20 20:08:02.846  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[36]}
2020-02-20 20:08:02.857  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349






2020-02-20 20:08:02.863  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:[]
2020-02-20 20:08:36.700  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.add', args=[Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=null, lastUpdateTime=null, view_times=0, type=Type{id='56', name=null}, tags=[], user=null, tagIds='18'}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09, {}]}
2020-02-20 20:08:36.881  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:08:36.894  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{message=Message{code=1, msg='标题为"jvm之java类加载机制和类加载器(ClassLoader)的详解"的博客更新成功。
您可以继续编辑修改博客。'}, blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:08:36 CST 2020, view_times=4, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:08:36 CST 2020, view_times=4, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:08:36.962  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:09:19.744  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.check', args=[36, {}]}
2020-02-20 20:09:19.971  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 20:09:20.517  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.content', args=[36]}
2020-02-20 20:09:20.519  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[36]}
2020-02-20 20:09:20.526  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349






2020-02-20 20:09:20.536  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:[]
2020-02-20 20:09:43.683  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.add', args=[Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=null, lastUpdateTime=null, view_times=0, type=Type{id='56', name=null}, tags=[], user=null, tagIds='18'}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09, {}]}
2020-02-20 20:09:43.935  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:09:43.953  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{message=Message{code=1, msg='标题为"jvm之java类加载机制和类加载器(ClassLoader)的详解"的博客更新成功。
您可以继续编辑修改博客。'}, blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:09:43 CST 2020, view_times=5, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:09:43 CST 2020, view_times=5, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:09:44.016  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:09:46.295  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.check', args=[36, {}]}
2020-02-20 20:09:46.383  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 20:09:46.903  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.content', args=[36]}
2020-02-20 20:09:46.910  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[36]}
2020-02-20 20:09:46.921  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  
#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349






2020-02-20 20:09:46.928  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:[]
2020-02-20 20:10:11.336  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.add', args=[Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=null, lastUpdateTime=null, view_times=0, type=Type{id='56', name=null}, tags=[], user=null, tagIds='18'}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09, {}]}
2020-02-20 20:10:11.529  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:10:11.536  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{message=Message{code=1, msg='标题为"jvm之java类加载机制和类加载器(ClassLoader)的详解"的博客更新成功。
您可以继续编辑修改博客。'}, blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:10:11 CST 2020, view_times=6, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:10:11 CST 2020, view_times=6, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:10:11.639  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:10:16.136  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.check', args=[36, {}]}
2020-02-20 20:10:16.332  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 20:10:17.214  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.content', args=[36]}
2020-02-20 20:10:17.217  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[36]}
2020-02-20 20:10:17.228  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349






2020-02-20 20:10:17.235  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:[]
2020-02-20 20:10:34.991  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.add', args=[Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=null, lastUpdateTime=null, view_times=0, type=Type{id='56', name=null}, tags=[], user=null, tagIds='18'}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09, {}]}
2020-02-20 20:10:35.193  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:10:35.211  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{message=Message{code=1, msg='标题为"jvm之java类加载机制和类加载器(ClassLoader)的详解"的博客更新成功。
您可以继续编辑修改博客。'}, blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:10:34 CST 2020, view_times=7, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:10:34 CST 2020, view_times=7, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:10:35.286  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:10:37.356  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.check', args=[36, {}]}
2020-02-20 20:10:37.601  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 20:10:38.427  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.content', args=[36]}
2020-02-20 20:10:38.434  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[36]}
2020-02-20 20:10:38.456  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349






2020-02-20 20:10:38.472  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:[]
2020-02-20 20:11:03.441  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.list', args=[Page request [number: 0, size 5, sort: lastUpdateTime: DESC], {}, org.apache.catalina.session.StandardSessionFacade@4ee0cd09]}
2020-02-20 20:11:03.469  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:management/blogs
2020-02-20 20:11:12.709  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 20:11:12.767  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 20:12:38.787  INFO 16572 --- [Thread-36] ationConfigEmbeddedWebApplicationContext : Closing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@5c80e338: startup date [Thu Feb 20 19:44:31 CST 2020]; root of context hierarchy
2020-02-20 20:12:38.792  INFO 16572 --- [Thread-36] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown
2020-02-20 20:12:38.794  INFO 16572 --- [Thread-36] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'
2020-02-20 20:12:39.796  INFO 16572 --- [restartedMain] com.peng.blog.BlogApplication            : Starting BlogApplication on LAPTOP-3JGI280N with PID 16572 (D:\workspaces\ideaWebWorkSpace\blog\target\classes started by 23185 in D:\workspaces\ideaWebWorkSpace\blog)
2020-02-20 20:12:39.796 DEBUG 16572 --- [restartedMain] com.peng.blog.BlogApplication            : Running with Spring Boot v1.5.9.RELEASE, Spring v4.3.13.RELEASE
2020-02-20 20:12:39.796  INFO 16572 --- [restartedMain] com.peng.blog.BlogApplication            : The following profiles are active: dev
2020-02-20 20:12:39.798  INFO 16572 --- [restartedMain] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@51d5fc2c: startup date [Thu Feb 20 20:12:39 CST 2020]; root of context hierarchy
2020-02-20 20:12:40.705  INFO 16572 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)
2020-02-20 20:12:40.706  INFO 16572 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-02-20 20:12:40.707  INFO 16572 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.23
2020-02-20 20:12:40.754  INFO 16572 --- [localhost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-02-20 20:12:40.755  INFO 16572 --- [localhost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 957 ms
2020-02-20 20:12:40.840  INFO 16572 --- [localhost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/]
2020-02-20 20:12:40.841  INFO 16572 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*]
2020-02-20 20:12:40.841  INFO 16572 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
2020-02-20 20:12:40.841  INFO 16572 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*]
2020-02-20 20:12:40.841  INFO 16572 --- [localhost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*]
2020-02-20 20:12:41.665  INFO 16572 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit 'default'
2020-02-20 20:12:41.666  INFO 16572 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [
	name: default
	...]
2020-02-20 20:12:41.734  INFO 16572 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL5Dialect
2020-02-20 20:12:41.829  INFO 16572 --- [restartedMain] org.hibernate.tool.hbm2ddl.SchemaUpdate  : HHH000228: Running hbm2ddl schema update
2020-02-20 20:12:42.233  INFO 16572 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-02-20 20:12:42.363  INFO 16572 --- [restartedMain] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
2020-02-20 20:12:42.890  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@51d5fc2c: startup date [Thu Feb 20 20:12:39 CST 2020]; root of context hierarchy
2020-02-20 20:12:42.907  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[ || /index.html],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.index(org.springframework.data.domain.Pageable,org.springframework.ui.Model)
2020-02-20 20:12:42.907  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/blog/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.check(int,org.springframework.ui.Model) throws com.peng.blog.exception.NotFoundException
2020-02-20 20:12:42.907  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.client.BlogController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 20:12:42.908  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comments/{id}],methods=[GET]}" onto public java.util.List<com.peng.blog.entity.Comment> com.peng.blog.web.client.BlogController.comments(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 20:12:42.908  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/content/{id}],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.content(int) throws com.peng.blog.exception.NotFoundException
2020-02-20 20:12:42.910  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/reply/{parent}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.reply(int,com.peng.blog.entity.Comment)
2020-02-20 20:12:42.911  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/comment/{blog}],methods=[POST]}" onto public com.peng.blog.entity.Comment com.peng.blog.web.client.BlogController.commentBlog(int,com.peng.blog.entity.Comment)
2020-02-20 20:12:42.911  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/searchPage],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.searchPage(java.lang.String,org.springframework.ui.Model)
2020-02-20 20:12:42.912  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/archive],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.BlogController.archive(org.springframework.ui.Model)
2020-02-20 20:12:42.913  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/tags],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TagClientController.showBlogByTag(com.peng.blog.utils.MyPage,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 20:12:42.914  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/types],methods=[GET]}" onto public java.lang.String com.peng.blog.web.client.TypeClientController.showBlogsByType(org.springframework.data.domain.Pageable,org.springframework.ui.Model,java.lang.Integer)
2020-02-20 20:12:42.915  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.add(com.peng.blog.entity.Blog,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 20:12:42.916  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog || /manage/blog/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.list(org.springframework.data.domain.Pageable,org.springframework.ui.Model,javax.servlet.http.HttpSession)
2020-02-20 20:12:42.916  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/search]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.search(org.springframework.data.domain.Pageable,com.peng.blog.entity.Blog,org.springframework.ui.Model)
2020-02-20 20:12:42.916  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/publish],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.publish(org.springframework.ui.Model,com.peng.blog.entity.Blog)
2020-02-20 20:12:42.916  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.BlogManageController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 20:12:42.917  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/blog/del],methods=[GET]}" onto public com.peng.blog.utils.Message com.peng.blog.web.management.BlogManageController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 20:12:42.917  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/logout],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.LoginController.logout(javax.servlet.http.HttpSession)
2020-02-20 20:12:42.918  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/login],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.LoginController.login(java.lang.String,java.lang.String,javax.servlet.http.HttpSession,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 20:12:42.923  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.add(com.peng.blog.entity.Tag,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 20:12:42.924  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag || /manage/tag/list],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.list(int,org.springframework.ui.Model)
2020-02-20 20:12:42.924  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TagController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 20:12:42.924  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 20:12:42.925  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/tag/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TagController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 20:12:42.926  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/add],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.add(com.peng.blog.entity.Type,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 20:12:42.927  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/list || /manage/type],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.list(int,org.springframework.ui.Model)
2020-02-20 20:12:42.927  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/search],methods=[POST]}" onto public java.lang.String com.peng.blog.web.management.TypeController.search(org.springframework.data.domain.Pageable,java.lang.String,org.springframework.ui.Model)
2020-02-20 20:12:42.927  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/edit],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.edit(int,org.springframework.web.servlet.mvc.support.RedirectAttributes) throws com.peng.blog.exception.NotFoundException
2020-02-20 20:12:42.927  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/manage/type/del],methods=[GET]}" onto public java.lang.String com.peng.blog.web.management.TypeController.del(int,org.springframework.web.servlet.mvc.support.RedirectAttributes)
2020-02-20 20:12:42.928  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t2]}" onto public java.lang.String com.peng.blog.web.TestController.t2(java.lang.String,int,boolean) throws com.peng.blog.exception.NotFoundException
2020-02-20 20:12:42.928  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t1]}" onto public java.lang.String com.peng.blog.web.TestController.t1(java.lang.String) throws com.peng.blog.exception.NotFoundException
2020-02-20 20:12:42.929  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/test/t3]}" onto public java.lang.String com.peng.blog.web.TestController.t3(int)
2020-02-20 20:12:42.930  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2020-02-20 20:12:42.931  INFO 16572 --- [restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error],produces=[text/html]}" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2020-02-20 20:12:42.960  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/about] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 20:12:42.960  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 20:12:42.960  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/index.html] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 20:12:42.961  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/welcome] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 20:12:42.962  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/type/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 20:12:42.962  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/manage/tag/publish] onto handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2020-02-20 20:12:42.970  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 20:12:42.970  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 20:12:42.985  INFO 16572 --- [restartedMain] .m.m.a.ExceptionHandlerExceptionResolver : Detected @ExceptionHandler methods in globalExceptionHandler
2020-02-20 20:12:42.998  INFO 16572 --- [restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2020-02-20 20:12:43.044  INFO 16572 --- [restartedMain] oConfiguration$WelcomePageHandlerMapping : Adding welcome page: class path resource [static/index.html]
2020-02-20 20:12:43.326  INFO 16572 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-02-20 20:12:43.387  INFO 16572 --- [restartedMain] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2020-02-20 20:12:43.424  INFO 16572 --- [restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2020-02-20 20:12:43.427  INFO 16572 --- [restartedMain] com.peng.blog.BlogApplication            : Started BlogApplication in 3.76 seconds (JVM running for 1697.708)
2020-02-20 20:12:55.513  INFO 16572 --- [http-nio-8080-exec-2] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2020-02-20 20:12:55.514  INFO 16572 --- [http-nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2020-02-20 20:12:55.528  INFO 16572 --- [http-nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 14 ms
2020-02-20 20:12:55.531  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/logout', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.LoginController.logout', args=[org.apache.catalina.session.StandardSessionFacade@38e5f7fc]}
2020-02-20 20:12:55.536  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage
2020-02-20 20:12:59.674  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/login', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.LoginController.login', args=[peng, 123456, org.apache.catalina.session.StandardSessionFacade@38e5f7fc, {}]}
2020-02-20 20:12:59.687  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/welcome
2020-02-20 20:13:24.831  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.list', args=[Page request [number: 0, size 5, sort: lastUpdateTime: DESC], {}, org.apache.catalina.session.StandardSessionFacade@38e5f7fc]}
2020-02-20 20:13:24.872  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:management/blogs
2020-02-20 20:13:28.808  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.list', args=[Page request [number: 1, size 5, sort: lastUpdateTime: DESC], {}, org.apache.catalina.session.StandardSessionFacade@38e5f7fc]}
2020-02-20 20:13:28.830  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:management/blogs
2020-02-20 20:13:30.147  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.list', args=[Page request [number: 0, size 5, sort: lastUpdateTime: DESC], {}, org.apache.catalina.session.StandardSessionFacade@38e5f7fc]}
2020-02-20 20:13:30.179  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:management/blogs
2020-02-20 20:13:36.244  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/edit', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.edit', args=[36, {}]}
2020-02-20 20:13:36.257  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:13:36.272  INFO 16572 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=2020-02-20 20:10:35.0, view_times=8, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=2020-02-20 20:10:35.0, view_times=8, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:13:36.345  INFO 16572 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:13:40.678  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.add', args=[Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=false, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=null, lastUpdateTime=null, view_times=0, type=Type{id='56', name=null}, tags=[], user=null, tagIds='18'}, org.apache.catalina.session.StandardSessionFacade@38e5f7fc, {}]}
2020-02-20 20:13:41.342  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:13:41.352  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{message=Message{code=1, msg='标题为"jvm之java类加载机制和类加载器(ClassLoader)的详解"的博客更新成功。
您可以继续编辑修改博客。'}, blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=false, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:13:40 CST 2020, view_times=8, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=false, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:13:40 CST 2020, view_times=8, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:13:41.417  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:13:42.838  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.list', args=[Page request [number: 0, size 5, sort: lastUpdateTime: DESC], {}, org.apache.catalina.session.StandardSessionFacade@38e5f7fc]}
2020-02-20 20:13:42.872  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:management/blogs
2020-02-20 20:13:46.464  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 20:13:46.498  WARN 16572 --- [http-nio-8080-exec-5] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 20:13:46.522  WARN 16572 --- [http-nio-8080-exec-5] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [null.size]; use collection function syntax instead [size(null)].
2020-02-20 20:13:46.566  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 20:13:49.919  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.check', args=[36, {}]}
2020-02-20 20:13:49.928  INFO 16572 --- [http-nio-8080-exec-4] c.p.blog.handler.GlobalExceptionHandler  : 调用handleException方法
2020-02-20 20:13:49.928 ERROR 16572 --- [http-nio-8080-exec-4] c.p.blog.handler.GlobalExceptionHandler  : 抛出异常:com.peng.blog.exception.NotFoundException: 没有该博客
2020-02-20 20:13:49.932  INFO 16572 --- [http-nio-8080-exec-4] c.p.blog.handler.GlobalExceptionHandler  : com.peng.blog.exception.NotFoundException存在ResponseStatus注解
2020-02-20 20:13:49.932 ERROR 16572 --- [http-nio-8080-exec-4] c.p.blog.handler.GlobalExceptionHandler  : 状态码404，继续抛出异常由SpringBoot自己处理
2020-02-20 20:13:49.932  WARN 16572 --- [http-nio-8080-exec-4] .w.s.m.a.ResponseStatusExceptionResolver : Resolved exception caused by Handler execution: com.peng.blog.exception.NotFoundException: 没有该博客
2020-02-20 20:14:33.883  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 20:14:33.929  INFO 16572 --- [http-nio-8080-exec-3] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 20:14:37.730  INFO 16572 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/edit', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.edit', args=[36, {}]}
2020-02-20 20:14:37.735  INFO 16572 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:14:37.752  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=false, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=2020-02-20 20:13:41.0, view_times=8, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=false, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=2020-02-20 20:13:41.0, view_times=8, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:14:37.808  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:14:39.234  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/add', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.add', args=[Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=null, lastUpdateTime=null, view_times=0, type=Type{id='56', name=null}, tags=[], user=null, tagIds='18'}, org.apache.catalina.session.StandardSessionFacade@38e5f7fc, {}]}
2020-02-20 20:14:39.426  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage/blog/publish
2020-02-20 20:14:39.434  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/blog/publish', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.BlogManageController.publish', args=[{message=Message{code=1, msg='标题为"jvm之java类加载机制和类加载器(ClassLoader)的详解"的博客更新成功。
您可以继续编辑修改博客。'}, blog=Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:14:39 CST 2020, view_times=8, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}, org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, Blog{id='36', title='jvm之java类加载机制和类加载器(ClassLoader)的详解', content='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349





', original=1, recommend_toggle=true, share_toggle=true, appreciate_toggle=true, comment_toggle=true, publish_toggle=true, picture_addr='https://i.picsum.photos/id/1/800/600.jpg', description='当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。', createTime=2020-02-20 20:05:22.0, lastUpdateTime=Thu Feb 20 20:14:39 CST 2020, view_times=8, type=Type{id='56', name=Java进阶}, tags=[Tag{id='18', name='类加载器'}], user=User{id='1', nickname='PENG', username='PENG', password='e10adc3949ba59abbe56e057f20f883e', email='231@qq.com', avatar='/images/headerImg.jpeg', admin=true, latest_time=2020-02-11 16:25:15.0, create_time=2020-02-11 16:25:02.0}, tagIds='18'}]}
2020-02-20 20:14:39.540  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:management/publishBlog
2020-02-20 20:14:41.887  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/manage/logout', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.management.LoginController.logout', args=[org.apache.catalina.session.StandardSessionFacade@38e5f7fc]}
2020-02-20 20:14:41.888  INFO 16572 --- [http-nio-8080-exec-4] com.peng.blog.aspect.LogAspect           : Return result:redirect:/manage
2020-02-20 20:14:43.782  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 20:14:43.829  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 20:14:51.905  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, null]}
2020-02-20 20:14:51.934  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 20:14:55.708  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/tags', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TagClientController.showBlogByTag', args=[MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, {myPage=MyPage{page=0, pageSize=5, totalPages=0, totalElements=0, isFirst=false, isLast=false, startIndex=0}, org.springframework.validation.BindingResult.myPage=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, 18]}
2020-02-20 20:14:55.955  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:tags
2020-02-20 20:14:57.142  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.check', args=[36, {}]}
2020-02-20 20:14:58.098  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 20:14:58.475  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.content', args=[36]}
2020-02-20 20:14:58.480  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[36]}
2020-02-20 20:14:58.487  INFO 16572 --- [http-nio-8080-exec-7] com.peng.blog.aspect.LogAspect           : Return result:当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349






2020-02-20 20:14:58.663  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:[]
2020-02-20 20:15:15.943  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comment/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.commentBlog', args=[36, Comment{id='null', content='讲得真好', nickname='', mail='', avatar='', publish_time=null, childs=[]}]}
2020-02-20 20:15:16.087  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:Comment{id='32', content='讲得真好', nickname='', mail='', avatar='/images/headerImg.jpeg', publish_time=Thu Feb 20 20:15:15 CST 2020, childs=[]}
2020-02-20 20:15:29.910  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/reply/32', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.reply', args=[32, Comment{id='null', content='1
', nickname='222', mail='222', avatar='', publish_time=null, childs=[]}]}
2020-02-20 20:15:30.194  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:Comment{id='33', content='1
', nickname='222', mail='222', avatar='/images/headerImg.jpeg', publish_time=Thu Feb 20 20:15:29 CST 2020, childs=[]}
2020-02-20 20:16:27.012  INFO 16572 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.check', args=[36, {}]}
2020-02-20 20:16:27.693  INFO 16572 --- [http-nio-8080-exec-8] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 20:16:28.193  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.content', args=[36]}
2020-02-20 20:16:28.197  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/36', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[36]}
2020-02-20 20:16:28.201  INFO 16572 --- [http-nio-8080-exec-5] com.peng.blog.aspect.LogAspect           : Return result:当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349






2020-02-20 20:16:28.210  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:[Comment{id='32', content='讲得真好', nickname='', mail='', avatar='/images/headerImg.jpeg', publish_time=2020-02-20 20:15:16.0, childs=[Comment{id='33', content='1
', nickname='222', mail='222', avatar='/images/headerImg.jpeg', publish_time=2020-02-20 20:15:30.0, childs=[]}]}]
2020-02-20 20:16:33.214  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, 12]}
2020-02-20 20:16:33.249  INFO 16572 --- [http-nio-8080-exec-2] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 20:16:33.863  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, 17]}
2020-02-20 20:16:33.890  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 20:16:34.477  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, 1]}
2020-02-20 20:16:34.507  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 20:16:34.829  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, 43]}
2020-02-20 20:16:34.860  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 20:16:35.497  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, 55]}
2020-02-20 20:16:35.549  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 20:16:35.929  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/types', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.TypeClientController.showBlogsByType', args=[Page request [number: 0, size 5, sort: createTime: DESC], {}, 53]}
2020-02-20 20:16:35.959  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:types
2020-02-20 20:16:36.891  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/archive', ip='0:0:0:0:0:0:0:1', classMethod='com.peng.blog.web.client.BlogController.archive', args=[{}]}
2020-02-20 20:16:36.907  INFO 16572 --- [http-nio-8080-exec-9] com.peng.blog.aspect.LogAspect           : Return result:archive
2020-02-20 20:19:13.876  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.index', args=[Page request [number: 0, size 6, sort: createTime: DESC], {}]}
2020-02-20 20:19:13.970  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:index
2020-02-20 20:19:16.700  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/blog/36', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.check', args=[36, {}]}
2020-02-20 20:19:17.057  INFO 16572 --- [http-nio-8080-exec-6] com.peng.blog.aspect.LogAspect           : Return result:blog
2020-02-20 20:19:17.634  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/content/36', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.content', args=[36]}
2020-02-20 20:19:17.642  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : RequestLog:RequestLog{url='http://localhost:8080/comments/36', ip='127.0.0.1', classMethod='com.peng.blog.web.client.BlogController.comments', args=[36]}
2020-02-20 20:19:17.670  INFO 16572 --- [http-nio-8080-exec-10] com.peng.blog.aspect.LogAspect           : Return result:当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。
![图片](https://img-blog.csdn.net/20180813115150336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
  
  
### 一、类加载过程
#### 1.加载  
&#160; &#160; &#160; &#160;加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。
&#160; &#160; &#160; &#160;类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
&#160; &#160; &#160; &#160;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。
- 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。
- 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
- 通过网络加载class文件。
- 把一个Java源文件动态编译，并执行加载。  

&#160; &#160; &#160; &#160;类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。  
#### 2.链接
&#160; &#160; &#160; &#160;当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。
- **验证**：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- **准备**：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。
- **解析**：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。  

#### 3.初始化
&#160; &#160; &#160; &#160;初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。  

### 二、类加载时机
1. 创建类的实例，也就是new一个对象
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（Class.forName("com.lyj.load")）
5. 初始化一个类的子类（会首先初始化子类的父类）
6. JVM启动时标明的启动类，即文件名和类名相同的那个类    

### 三、类加载器
&#160; &#160; &#160; &#160;类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。  
1). **根类加载器**（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。  
下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：  
```java
public class ClassLoaderTest {
 
	public static void main(String[] args) {
		
		URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
		for(URL url : urls){
			System.out.println(url.toExternalForm());
		}
	}
}
```
运行结果：
![结果](https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
2). **扩展类加载器**（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。  

3). **系统类加载器**（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。  
类加载器加载Class大致要经过如下8个步骤：
- 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
- 如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
- 请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
- 请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
- 当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
- 从文件中载入Class，成功后跳至第8步。
- 抛出ClassNotFountException异常。
- 返回对应的java.lang.Class对象。  

### 四、类加载机制：
#### 1.**JVM的类加载机制**主要有如下*3种*。  
- **全盘负责**：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- **双亲委派**：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
- **缓存机制**。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。  

#### 2.这里说明一下双亲委派机制：
![双亲委派](https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  
  
&#160; &#160; &#160; &#160;双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。  
&#160; &#160; &#160; &#160;双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。  
原文链接：https://blog.csdn.net/m0_38075425/article/details/81627349






2020-02-20 20:19:17.754  INFO 16572 --- [http-nio-8080-exec-1] com.peng.blog.aspect.LogAspect           : Return result:[Comment{id='32', content='讲得真好', nickname='', mail='', avatar='/images/headerImg.jpeg', publish_time=2020-02-20 20:15:16.0, childs=[Comment{id='33', content='1
', nickname='222', mail='222', avatar='/images/headerImg.jpeg', publish_time=2020-02-20 20:15:30.0, childs=[]}]}]
